#include "scenarios_generator_engine.h"
#include "corn/OS/file_system_engine.h"
#include "corn/datetime/date.hpp"
#include "corn/data_source/generic_datarec.h"
//161116 #include "CS_suite/file_system/CS_file_discovery.h"
#include "CS_suite/file_system/CS_context_discovery.h"
#if (defined (_Windows) || defined(_WIN32) || defined(_WIN64))
#   include "corn/OS/file_system_engine_Windows.h"
#endif
namespace CS {
//______________________________________________________________________________
Scenarios_generator_engine::Scenarios_generator_engine(Arguments &arguments_)
: databases          (0)
, arguments          (arguments_)
, predefined_combinations   (arguments_)
{}
//______________________________________________________________________________
bool Scenarios_generator_engine::initialize()                    initialization_
{  bool initialized = true;
   // Exclude files and directories that the user
   // might be hiddent or not consider.
   arguments.seclusion.exclude_pattern_cstr("desktop");
   arguments.seclusion.exclude_pattern_cstr("desktop.ini");
   arguments.seclusion.exclude_pattern_cstr(".directory");
   arguments.seclusion.exclude_pattern_cstr(".svn/");
   arguments.seclusion.exclude_pattern_cstr(".svn/*");
   if (initialized)  // so far viable
      databases = new Databases(arguments.start_directory);
         // now allow the the target to be a subscenario to use any accessible database
         //  scenario(*scenarios_directory);
   if (arguments.verbose) std::clog << "info: Loading predefined sites" << std::endl;
   predefined_combinations.load();
   if (arguments.verbose) std::clog << "info: generating " << arguments.generate_directory.c_str() << std::endl;
   return true;
}
//______________________________________________________________________________
nat32 Scenarios_generator_engine::provide_scenario_levels()           provision_
{
   provide_database_subdirectories();
   FOR_EACH_IN(subdir,CORN::OS::Directory_name ,database_subdirectories,each_subdir)
   {
      if (arguments.seclusion
          .is_included_DEN(*subdir))
      {
//std::clog << subdir->c_str() << std::endl;
         Scenario_level *scenario_level = provide_new_scenario_level(*subdir);
      }
   } FOR_EACH_END(each_subdir)
   return scenario_levels_primary.count();
}
//______________________________________________________________________________
Scenarios_generator_engine::Scenario_level *Scenarios_generator_engine
::provide_new_scenario_level
(const CORN::OS::Directory_name &dir_name)                           provision_
{
   Scenario_level *provided = 0;
   CORN::Text_list path_list;
   dir_name.append_path_list_to(path_list, CORN::OS::Directory_entry_name::include_all);
   while (path_list.find_cstr("Database"))
   {  // strip off the path upto and including Database
      path_list.delete_at(0);
   }
   CORN::Text_list::Item *primary_scenario_level_name =
      dynamic_cast<CORN::Text_list::Item *>(path_list.pop_at_head());
   if (primary_scenario_level_name) // the name is actually guarenteed at this point
   {  provided = scenario_levels_primary.provide_new_scenario_level
         (*primary_scenario_level_name,path_list,dir_name
         ,arguments.seclusion
         ,arguments.scenario_level_recognition);
   }
   return provided;
}
//______________________________________________________________________________
Scenarios_generator_engine::Scenario_level *
Scenarios_generator_engine::Scenario_levels::provide_new_scenario_level
( const std::string             &level_name
, CORN::Text_list               &path_list
,const CORN::OS::Directory_name &dir_name
,const CORN::Seclusion          &seclusions
,const CORN::Seclusion          &scenario_level_recognition)
{
   Scenario_level *provided = 0;
   Scenario_level *scenario_level = dynamic_cast<Scenario_level *>(find_string(level_name));

//std::cout << "dir_name" << dir_name.c_str() << std::endl;


   if (!scenario_level)
   {  scenario_level = new Scenario_level(level_name);
      append(scenario_level);
   }
   if (path_list.count())
   {
      // This directory appears to have secondary
      // levels I.e. Weather/GCM/RCPx.x or Initial/xxx/xxx
      // Note that when there are sub directories, the generator currently
      // excludes the Primary directory name (I.e. Weather) from combinatorics
      // (I.e. the GCM and RCPx.x directory levels are included)
      for
         (CORN::Text_list::Item *next_potential_level = dynamic_cast<CORN::Text_list::Item *>(path_list.pop_at_head())
         ;next_potential_level
         ;next_potential_level = dynamic_cast<CORN::Text_list::Item *>(path_list.pop_at_head()))
      {
         if (seclusions.is_excluded_string(*next_potential_level,false,false))
         {  // Explictly excluded directory (I.e. exported)
            // None of the contents of this directory would be included
            // in combinations and it is not included as a level.
            delete next_potential_level;
         } else
         {  // this is an included directory it may be
            // an user defined level name (I.e. Under Initial)
            // or a scenario name (I.e. a GCM or a RCP)
            std::string next_level_name(level_name); next_level_name.append("X");
            {
               provided = scenario_level->sublevels.provide_new_scenario_level
                  (next_level_name,path_list,dir_name
                  ,/*arguments.*/seclusions
                  ,scenario_level_recognition
                  );
               //sublevels.append(provided); // unique
            }
            delete next_potential_level;
         }
      } // for
   } else
   {

//std::clog << "added subitems:" << dir_name.c_str() << std::endl; //debug

      scenario_level->added_subitems(dir_name,seclusions);

//scenario_level->files.write(std::clog);


      provided = scenario_level;
   }
   return scenario_level;
}
//______________________________________________________________________________
nat32 Scenarios_generator_engine::Scenario_level::added_subitems
(const CORN::OS::Directory_name &dir_name
,const CORN::Seclusion &seclusions)
{
   nat32 DEN_items = CORN::OS::file_system_engine.
      list_DENs
      (dir_name,&scenario_files,&directories
      ,seclusions
      ,CORN::OS::File_system::none_recursion_inclusive,0);
      // note when there are no scenario directories
      // all files are assumed to be scenarios
      // we dont move files to scenarios list yet
      // because we have to wait till all the directories
      // in all the Databases have been collected.
   return DEN_items;
}
//______________________________________________________________________________
nat32 Scenarios_generator_engine::provide_database_subdirectories()   provision_
{  return databases->render_subdirectories(database_subdirectories,arguments.seclusion,arguments.verbose);
}
//______________________________________________________________________________
nat32 Scenarios_generator_engine::provide_database_parameter_files()  provision_
{  nat32 param_file_count = database_parameter_files.count();
   if (!param_file_count)
   FOR_EACH_IN(database_subdir,CORN::OS::Directory_name,database_subdirectories,each_database_subdir)
   {  param_file_count = CORN::OS::file_system_engine.list_DENs
         (*database_subdir
         ,&database_parameter_files,0
         ,arguments.seclusion
         ,CORN::OS::File_system::subdirectory_recursion_exclusive);
   } FOR_EACH_END(each_database_subdir)
   return  param_file_count;
}
//______________________________________________________________________________
nat32 Scenarios_generator_engine::provide_preestablished_subscenario_directories() provision_
{
   CORN::Seclusion generate_dir_seclusion;
   generate_dir_seclusion.exclude_pattern_cstr(".svn/");
   generate_dir_seclusion.exclude_pattern_cstr("Output/");
   generate_dir_seclusion.exclude_pattern_cstr("collate/");
   generate_dir_seclusion.include_pattern_cstr("*/");

   nat32 existing_count = existing_subscenarios_leaves.count();
   if (!existing_count)
   {  CORN::Unidirectional_list all_subscenarios;
      CORN::OS::file_system_engine.list_DENs //entry_names
         (arguments.generate_directory
         ,0,&all_subscenarios
         ,generate_dir_seclusion
         ,CORN::OS::File_system::subdirectory_recursion_inclusive);
      // all_subscenarios may include generate scenarios which we now omit.
      for (CORN::OS::Directory_name *subscenario = dynamic_cast<CORN::OS::Directory_name *>(all_subscenarios.pop_first())
          ;subscenario
          ;subscenario = dynamic_cast<CORN::OS::Directory_name *>(all_subscenarios.pop_first()))
      {  // If there are any subdirectories, this not a preexisting leaf scenario
         CORN::Unidirectional_list any_sub_dirs;
         CORN::OS::file_system_engine.list_DENs
            (*subscenario,0,&any_sub_dirs,CORN::Inclusion("*/",false)
            ,CORN::OS::File_system::subdirectory_recursion_inclusive);
         if (any_sub_dirs.count())
            delete subscenario;
         else
            existing_subscenarios_leaves.append(subscenario); // should be a leaf subscenario
      }
      existing_count = existing_subscenarios_leaves.count();
   } // else we have already provided
   return existing_count;
}
//______________________________________________________________________________
bool Scenarios_generator_engine::Arguments::is_scenarios_directory
(const CORN::OS::Directory_name &directory)                  affirmation_
{  // Eventually Scenarios directory will be identified by landmark
   return directory.get_name() == L"Scenarios";
}
//______________________________________________________________________________
bool Scenarios_generator_engine::generate()
{  bool generated = true;

   // Get any subscenario directories that the user has defined by hand
   // Any parameter files discovered in these scenarios will be
   // excluded from the combinitorics because the have already been situated
   // in these scenario directories.


   // the target directory is now assumed to be fully
   // generated it is up to the user to decided if generated
   // subdirectories are to be considered permenent
   // the user should always create a new directory inwhich to generate
   // senarios using the --template option to preserve predefine scenario structure
   // gendir_parameter_file_seclusion.exclude_pattern_cstr("*.generated");
   // Output directories will not have parameter files.

   if (arguments.verbose)
      std::clog << "info: identifying preestablished scenario parameter file selections" << std::endl;
   CORN::Seclusion gendir_parameter_file_seclusion;
   gendir_parameter_file_seclusion.exclude_pattern_cstr("Output/");
   gendir_parameter_file_seclusion.exclude_pattern_cstr("collate/");

   gendir_parameter_file_seclusion.include_pattern_cstr("*/");
   gendir_parameter_file_seclusion.include_pattern_cstr("*");
   CORN::Unidirectional_list preestablished_scenario_used_parameter_files;
   CORN::OS::file_system_engine.list_DENs //entry_names
         (arguments.generate_directory
         ,&preestablished_scenario_used_parameter_files,0
         ,gendir_parameter_file_seclusion
         ,CORN::OS::File_system::subdirectory_recursion_inclusive);
      if (arguments.verbose) std::clog << "info: identifying preestablished scenarios." << std::endl;
   provide_preestablished_subscenario_directories();
   // we should now have only leaf directories

   FOR_EACH_IN(used_param_file,CORN::OS::File_name,preestablished_scenario_used_parameter_files,each_used_param_file)
   {
      std::wstring used_param_file_nameW; std::string used_param_file_name;
      used_param_file->get_name_with_extension(used_param_file_nameW);
      CORN::wstring_to_string(used_param_file_nameW,used_param_file_name);
      if (arguments.verbose) std::clog << "exclude: " << used_param_file_name.c_str() << std::endl;
      arguments.seclusion.exclude_pattern_cstr(used_param_file_name.c_str());
   } FOR_EACH_END(each_used_param_file)

   // We must provides scenario levels have excluding predefined scenario
   // used parameter files because we need to exclude these from
   // from potential scenario levels

   arguments.seclusion.include_pattern_cstr("*"); // Include all other files
   arguments.seclusion.include_pattern_cstr("*/"); // Include all other directories

   provide_scenario_levels();

   if (existing_subscenarios_leaves.count())
   {  //
      FOR_EACH_IN(preestablished_scenario_leaf,CORN::OS::File_name,existing_subscenarios_leaves,each_preestablished_scenario)
      {  // At this point
         std::clog << "predefined leaf: " << preestablished_scenario_leaf->c_str();
         if (predefined_combinations.count())
              generate_predefined_combination_scenario_level(scenario_levels_primary,*preestablished_scenario_leaf);
         else generate_scenario_level(scenario_levels_primary,*preestablished_scenario_leaf);
      } FOR_EACH_END(each_preestablished_scenario)
   } else
      if (predefined_combinations.count())
           generate_predefined_combination_scenario_level(scenario_levels_primary,(arguments.generate_directory));
      else generate_scenario_level(scenario_levels_primary,(arguments.generate_directory));
   CORN::OS::file_system_engine.set_current_working_directory(arguments.start_directory);
   return generated;
}
//______________________________________________________________________________
bool Scenarios_generator_engine::generate_predefined_combination_scenario_level
(const Scenario_levels &scenario_levels
,const CORN::OS::Directory_name &specific_scenario_path )
{
   nat32 generated = 0;
   FOR_EACH_IN(predefined_scenario,Predefined_site,predefined_combinations,each_predefined)
   {
       std::string predefined_scenario_name;
      // scenario combination tables dont necessarily have geocoordinates (defining sites)
      // it could be simply a set of subscenario combinations
      if (predefined_scenario->Geocoordinate::is_valid())
      {
         // scenario_name is simply the predefined_scenario geocoordinate
         if (predefined_combinations.fields_dBase->geocoordinate) // use user specified geocoordinate (code)
         {  char buffer[100];
            predefined_scenario
               ->know_format(predefined_combinations.fields_dBase->geocoordinate_format);
            predefined_scenario_name= predefined_scenario->label_cstr(buffer);
         }
         else
            // Conceptual: the format options could be specified as command line arguements
            predefined_scenario->
               label_decimal_degrees_with_format
                  (predefined_scenario_name
                  , true // use N S E W
                  ,4 // precision_latitude
                  ,4 // precision_longitude
                  ,'0' // zero_fill_char   (need to check this)
                  ,0,0);  // no elevation no separator
      } else
      {  if (predefined_combinations.fields_dBase->ID)
         {  predefined_scenario_name = predefined_scenario->ID;
         } else
         {
            std::cerr << "error: dbf file must have geocoordinate fields or unique ID field" << std::endl;
            return false;
            //Conceptual
            //compose unique name from field_names (that are actual Database context names)

         }
      }
      CORN::OS::Directory_name_concrete scenario_directory(specific_scenario_path,predefined_scenario_name);
      CORN::OS::file_system_engine.create_directory(scenario_directory);
      FOR_EACH_IN(pot_scenario_element,Predefined_site::Potential_scenario_element,predefined_scenario->other_potential_elements,each_pot_element)
      {
         std::wstring database_context_name;
         CORN::string_to_wstring(pot_scenario_element->field_name,database_context_name);
         CORN::OS::File_name *parameter_filename_name_qual
            = databases->render_find_in_context_string_any_extension
            (database_context_name
            ,pot_scenario_element->scenario_value);
         if (parameter_filename_name_qual)
         {
            std::wstring param_file_name_unqual;
            parameter_filename_name_qual->get_name_with_extension(param_file_name_unqual);
            CORN::OS::File_name_concrete link_file_name(specific_scenario_path,param_file_name_unqual);
            create_best_kind_of_link(*parameter_filename_name_qual,link_file_name);
         }  // field is not a Database context_name (not error)
      } FOR_EACH_END(each_pot_element)
      generated += generate_scenario_level(scenario_levels,scenario_directory);
   } FOR_EACH_END(each_predefined)
   return generated > 0;;
}
//_2016-11-21___________________________________________________________________
bool Scenarios_generator_engine::generate_scenario_level
(const Scenario_levels &scenario_levels
,const CORN::OS::Directory_name &specific_scenario_path )
{
/*
don't forget if this scenario level database directory
has both files and folders
we need to make links to each of the (included) files at this generated scenario directory.

for leaf (Database scenarios) directories,
all files are assumed to be scenarios
*/

   bool generated = true;
   std::clog << "ssp:" << specific_scenario_path.c_str() << std::endl;

   // I think now this line is obsolete:
//   CORN::OS::file_system_engine.create_directory(specific_scenario_path);

   if (scenario_levels.count())
   {

   FOR_EACH_IN(scenario_level,Scenario_level,scenario_levels,each_level)
   {
      if (scenario_level->directories.count())
      {  // This level (directory) contains subdirectories which are presumed to be subscenarios
         /* now ancillary files are copied from each corresponding source scenario directory
         FOR_EACH_IN(ancillary_file,CORN::OS::File_name,scenario_level->Xfiles,each_ancil_file)
         {  // Any files are ancillary files which we will link to the Database location
            // These could be fragment(s) (template) for parameter files in subdirectories (to compose/inherit)
            // or some arbitrary file(s) that it would be convenient to reference.
            std::wstring name_with_ext;
            CORN::OS::File_name_concrete target_ancillary_filename
               (specific_scenario_path,ancillary_file->get_name_with_extension(name_with_ext));
            create_best_kind_of_link(*ancillary_file,target_ancillary_filename);
         } FOR_EACH_END(each_ancil_file)
         */
         FOR_EACH_IN(source_scenario,CORN::OS::Directory_name,scenario_level->directories,each_scenario)
         {
            std::wstring name_with_extW;
            source_scenario->get_name_with_extension(name_with_extW);
            std::string name_with_ext; CORN::wstring_to_string(name_with_extW,name_with_ext);
            if (arguments.scenario_level_recognition.is_included_string(name_with_ext))
            {
               CORN::OS::Directory_name_concrete next_level_name
                  (specific_scenario_path,name_with_ext);
               CORN::OS::file_system_engine.create_directory(next_level_name);   //161209
               // Get and copy source scenario ancillary files
               // we do want to apply any user specified seclusions
               CORN::Unidirectional_list ancillary_files;
               CORN::Unidirectional_list directory_names_would_be_scenarios;
               CORN::OS::file_system_engine.list_DENs                               //161209
                  (*source_scenario,&ancillary_files,&directory_names_would_be_scenarios,arguments.seclusion
                  ,CORN::OS::File_system::none_recursion_inclusive);
               if (directory_names_would_be_scenarios.count())
               {  // When the source scenario has subdirectories (subscenarios) then
                  // any files also in this directory are assumed to be
                  // ancillary files which we now link to in the target.
                  FOR_EACH_IN(ancillary_file,CORN::OS::File_name,ancillary_files,each_ancil_file) //161209
                  {  std::wstring ancillary_file_name_with_ext;
                     CORN::OS::File_name_concrete target_ancillary_filename
                        (next_level_name,ancillary_file->get_name_with_extension(ancillary_file_name_with_ext));
                     create_best_kind_of_link(*ancillary_file,target_ancillary_filename);
                  } FOR_EACH_END(each_ancil_file)
               }  // else if there are no subdiretories (subscenarios)
                  // the files in this directory represent subscenario
                  // so these will be handled elsewhere
               generate_scenario_level(scenario_level->sublevels,next_level_name);
            } else
               generate_scenario_level(scenario_level->sublevels,specific_scenario_path);
         } FOR_EACH_END(each_scenario)
      } else
      {  // file names are scenario names

         CORN::Container &potential_UED_files = scenario_level->scenario_files;
         CORN::OS::File_name *any_potential_UED_file =
            dynamic_cast<CORN::OS::File_name *>(potential_UED_files.get_at(0));
         if (any_potential_UED_file && any_potential_UED_file->has_extension_ASCII("UED"))
         {

            //if there are any (UED) weather files in the scenario level (source) directory.
            // (which may be excluded from scenarios) as is the case in N2O_emit project

            std::string geocoordinate_ISO_6709;

//std::clog << "ssp:" << specific_scenario_path.c_str() << std::endl;

            CS::Context_discovery discovery(specific_scenario_path);             //161116
            //161116 CS::File_discovery discovery(specific_scenario_path);
            // CORN::OS::Directory_name *scenarios = discovery.provide_Scenarios();
            discovery.know_root(discovery.provide_Scenarios());                  //161116
            // It is expected that this program is run in/under a project's
            // Scenarios directory, if not an alternate default root chosen
            // this would likely be a project directory.

            //161116 discovery.set_level_as_root(CS::File_discovery::scenarios_level);
               // actually the root is scenarios and it is known now
               // but it currently isn't accessible
            Geolocation geolocation;
//std::clog << "ssp:" << specific_scenario_path.c_str() <<std::endl;
            bool found_geocoordinate = discovery.get_geolocation
               (specific_scenario_path,"geocoordinate"
               ,geolocation,geocoordinate_ISO_6709);
            if (found_geocoordinate)
            {
               std::wstring weather_name_ext;
               CORN::append_string_to_wstring(geocoordinate_ISO_6709,weather_name_ext);
               weather_name_ext.append(L".");
               weather_name_ext.append(L"UED");

               CORN::Text_list appropriates;
               // I really should propogate the items in the path
               // to be more specific,
               // rather than specific_scenario_path->append_path_list_to
               // but this should work.
               specific_scenario_path.append_path_list_to
                  (appropriates
                  ,CORN::OS::Directory_entry_name::include_all);
               appropriates.add_wstring(weather_name_ext);

//std::clog << "approps:";
//appropriates.write(std::clog); std::clog << std::endl;

               const CORN::OS::File_name &most_appropriate_filename
                  = find_most_appropriate_filename
                     (appropriates,potential_UED_files);

//std::clog << "most appropriate:" << most_appropriate_filename.c_str() << std::endl;

               CORN::OS::File_name_concrete link_file_name(specific_scenario_path,weather_name_ext);
               create_best_kind_of_link(most_appropriate_filename,link_file_name);

/*
                  //geolocation_weather_file(scenario_dir_name,weather_name_ext);
               FIND_FOR_EACH_IN(found_database_UED,database_UED,CORN::OS::File_name
                  ,potential_UED_files,true,iterator)
               {
                  std::wstring database_name_UED;
                  database_UED->get_name_with_extension(database_name_UED);
                  std::wstring scenario_name; specific_scenario_path.get_name_with_extension(scenario_name);
                  std::wstring UED_parentdir_name; database_UED->get_parent_directory_name_qualified().get_name_with_extension(UED_parentdir_name);

                  // continue here, need to check more of the parent path directories
                  // because not pickin up the GCM
                  // may need to have a count of sub scenarios to check the path

                  if ((database_name_UED == weather_name_ext) && (scenario_name == UED_parentdir_name))
                  {
                     found_database_UED = database_UED;
                     CORN::OS::File_name_concrete link_file_name(specific_scenario_path,weather_name_ext);
                     create_best_kind_of_link(*found_database_UED,link_file_name);
                  }
               } FOR_EACH_END(iterator)
*/
            }
         } else
         FOR_EACH_IN(filename_specifies_potential_scenario,CORN::OS::File_name,scenario_level->scenario_files,each_scenario_file)
         {
            CORN::OS::Directory_name_concrete scenario_dir_name(specific_scenario_path,filename_specifies_potential_scenario->get_name());
            CORN::OS::file_system_engine.create_directory(scenario_dir_name,true);

            {  // All other files would be VV files so we can use inheritance (or symbolic links for linux)
               std::wstring name_ext; filename_specifies_potential_scenario->get_name_with_extension(name_ext);
               CORN::OS::File_name_concrete link_file_name(scenario_dir_name,name_ext);
               create_best_kind_of_link(*filename_specifies_potential_scenario,link_file_name);
            }
         } FOR_EACH_END(each_scenario_file)
      }
   } FOR_EACH_END(each_level)

   //NYI  for terminal scenario add link(s) to parameter files
   // not already specified by scenario level (I.e. soil file)
   }
   #ifndef __linux__
   CORN::OS::File_name_concrete run_bat_filename(specific_scenario_path,"run.bat");
   std::ofstream run_bat_file(run_bat_filename.c_str());
   CORN::Text_list scenario_dirs;
   nat32 scenario_dir_count = CORN::OS::file_system_engine.list_names_in
      (specific_scenario_path,0,&scenario_dirs);
   if (scenario_dir_count)
   {  FOR_EACH_IN(scenario_dir,CORN::Text_list::Item,scenario_dirs,each_scenario)
      {
         run_bat_file << "PUSHD \""  << scenario_dir->c_str() << "\"" << std::endl;
         run_bat_file << "CALL \"" << "run.bat\"" << std::endl;
         run_bat_file << "POPD "  << scenario_dir->c_str() << std::endl;
      } FOR_EACH_END(each_scenario)
   } else
   { // This is just temporary until I get the scenario scheduler running
      run_bat_file << "cmd.exe /c \"C:\\Program Files (x86)\\CS_Suite_5\\CropSyst\\CropSyst_5.exe\"" << std::endl;
   }
   #endif
   return generated;
}
//______________________________________________________________________________
const CORN::OS::File_name &Scenarios_generator_engine::find_most_appropriate_filename
(const CORN::Text_list &appropriates
,const CORN::Container &canidate_filenames)                                const
{
   const CORN::OS::File_name *most_appropriate_candidate = 0; nat8 mosts_appropriateness = 0;
   FOR_EACH_IN(candidate,const CORN::OS::File_name,canidate_filenames,each_candidate)
   {  CORN::Text_list candidate_path_items;
      candidate->append_path_list_to(candidate_path_items,CORN::OS::Directory_entry_name::include_all);
      nat8 appropriateness = 0;
      FOR_EACH_IN(appropriate,CORN::Text_list::Item,appropriates,each_approp)
      {  FOR_EACH_IN(dir_name,CORN::Text_list::Item,candidate_path_items, each_dir_name)
         {  if ((*dir_name) == (*appropriate))
               appropriateness++;
         } FOR_EACH_END(each_dir_name)
      } FOR_EACH_END(each_approp)
      if (appropriateness >= mosts_appropriateness)
      {  // The >= would select the matching file closest to the scenario directory
         most_appropriate_candidate = candidate;
         mosts_appropriateness = appropriateness;
      }
   } FOR_EACH_END(each_candidate)
   return *most_appropriate_candidate;
}
//______________________________________________________________________________
bool Scenarios_generator_engine::create_best_kind_of_link
(const CORN::OS::File_name &source_filename
,const CORN::OS::File_name &target_filename)
{  bool linked = true;
   if (CORN::OS::file_system_engine.exists(target_filename)) return false;
   if (is_VV_file(source_filename))
      // Not currently checking if actually file type does support iheritance
      // as most CS Suite VV (parameter) files support inheritance linking
   {
      std::ofstream target(target_filename.c_str());
      target
         << "[inherit]"                      << std::endl
         << "1=" << source_filename.c_str()  << std::endl;
   } else
   {  // file format not recognized as having inheritance linking
      // so default to soft links
      // prefer soft links,
      #ifdef __unix__
      CORN::OS::file_system_engine.create_file_link
         (source_filename,target_filename,LINK_SYMBOLIC);
      #endif
      #ifdef _Windows
      {
         CORN::OS::File_system_engine_Windows *file_sys_engine_Windows
            = dynamic_cast<CORN::OS::File_system_engine_Windows *>
               (&CORN::OS::file_system_engine);
                  // in Windows softlinks are poorly implemented
                  // so use hard links or shortcuts.
         if (file_sys_engine_Windows)
         {  std::wstring file_and_ext;
            linked = file_sys_engine_Windows->create_shortcut
               (source_filename // The file to link to
               ,target_filename.get_parent_directory_name_qualified()
               ,target_filename.get_name_with_extension(file_and_ext)
               ,L"Link");
         } else linked = false;
      }
      #endif
   }
   return linked;
}
//______________________________________________________________________________
bool Scenarios_generator_engine::is_VV_file
(const CORN::OS::File_name &target_filename)                        affirmation_
{
   std::ifstream target(target_filename.c_str());
   std::string line;
   // read first few lines
   for (nat8 c = 0; c <20; c++)
   {
      getline(target,line);
      // if has [ and ] then this appears to be VV file return true;
      nat32 l_brace_pos = line.find_first_of('[');
      nat32 r_brace_pos = line.find_first_of(']');
      if ((l_brace_pos == 0)                                                     //161117
        &&(l_brace_pos != std::string::npos)
        &&(r_brace_pos != std::string::npos))
         return true;
   }
   return false;
}
//______________________________________________________________________________
/*obsolete directory name with time is specified by the script / caller
bool Scenarios_generator_engine::rename_target_directory()
{

   std::wstring date_suffix;
   arguments.generate_directory->get_name_with_extension(date_suffix);
   std::wstring target_name;
   CORN::OS::Directory_name_concrete *target_directory = 0;

   if (arguments.target_name_specified.length()) // specified name has priority
      target_name.assign(arguments.target_name_specified);
   else
   {  if (arguments.target_name_template_composed.length())
      {
         target_name.assign(arguments.target_name_template_composed);
         CORN::append_ASCIIz_to_wstring("_",target_name);
      } // else just use date
      target_name += date_suffix;
   }
   target_directory = new CORN::OS::Directory_name_concrete
      (arguments.start_directory,target_name);

   bool renamed = false;
   if (target_directory)
   {
      renamed = CORN::OS::file_system_engine.rename(*(arguments.generate_directory),*target_directory);
      #ifdef _Windows
      // In Windows this program locks the directory. Create a batch file
      // to rename the directory after a brief pause.
      //CORN::OS::File_name_concrete rename_batch(ar
      {
      std::ofstream rename_bat("rename_scenario.bat");
      std::wstring target_name_extW;
      target_directory->get_name_with_extension(target_name_extW);
      std::string target_name_ext; CORN::wstring_to_string(target_name_extW,target_name_ext);
      rename_bat << "timeout /t 3 /nobreak >NUL" << std::endl
         << "rename \"" << arguments.generate_directory->c_str() << "\" \"" << target_name_ext << "\"" << std::endl
         << "exit" << std::endl;
      }
      system ("start /b rename_scenario.bat");
      #else
      // Not sure yet if this also a problem in Linux
      #endif
   }
   std::clog << "info: rename target" << std::endl;
   std::clog
      << "source=" << arguments.generate_directory->c_str()  << std::endl
      << "target=" << target_directory->c_str()    << std::endl;
   delete target_directory;
   return renamed;
}
*/
//______________________________________________________________________________
Scenarios_generator_engine::Arguments::Arguments()
: ARGUMENTS_SUPERCLASS() //CORN::Arguments()
, generate_directory()
{
/*//161205
   CORN::Date_time_64 now;
   std::string now_str; CORN::append_float64_to_string(now.get_datetime64(),4,now_str);
   generate_directory=new CORN::OS::Directory_name_concrete
      (start_directory,now_str,CORN::OS::directory_entry);
*/
   generate_directory=new CORN::OS::Directory_name_concrete();                   //161205
   find_responses = FIND_RESPONSES_LAST;
}
//______________________________________________________________________________
Scenarios_generator_engine::Arguments::~Arguments()
{}
//______________________________________________________________________________
bool Scenarios_generator_engine::Arguments::write_help()                         const
{
   std::cout
      << "All arguments are optional and there is no fixed order." << std::endl << std::endl;
   return ARGUMENTS_SUPERCLASS/*CORN::Arguments*/::write_help();
}
//______________________________________________________________________________
bool Scenarios_generator_engine::Arguments::get_author_mailto_URI(std::string &email_address) const
{  email_address = "mailto:rnelson@wsu.edu";
   return true;
}
//______________________________________________________________________________
bool Scenarios_generator_engine::Arguments::recognize_assignment
(const std::string &variable
,const std::string &value)                                         modification_
{  bool recognized = false;
   if (variable == "--target")
   {
      CORN::string_to_wstring(value,target_name_specified);
      CORN::OS::Directory_name_concrete target_gen_dir(start_directory,target_name_specified);
//      generate_directory.set_DEN(target_gen_dir);

      generate_directory.set_wstr(target_gen_dir.w_str());
      recognized = true;
   }
   if (variable == "--template")
   {
      CORN::OS::Directory_name *template_scenario = new
         CORN::OS::Directory_name_concrete(value);
      if (verbose) std::clog << "info: template " << template_scenario->c_str() << std::endl;
      if (CORN::OS::file_system_engine.exists(*template_scenario))
      {
         if (verbose) std::clog << "info: copying template." << std::endl; // << template_scenario->c_str() << std::endl;
         if (target_name_template_composed.length()) target_name_template_composed.append(L"_"); // separator
         target_name_template_composed.append(template_scenario->get_name()); // don't include extension which would likely be .template
         CORN::OS::file_system_engine.copy_directory_contents                    //161105
            (*template_scenario,generate_directory,0,true,false);
         /*161105 moved to copy_directory_contents;
         if (CORN::OS::file_system_engine.exists(generate_directoryX ))
         {  // If the target already exists copy  copies the
            // source into the target but we want to copy the source files.
            CORN::Unidirectional_list contents_files;
            CORN::Unidirectional_list contents_diretories;
            CORN::OS::file_system_engine.list_DENs
               ((*template_scenario)
               ,&contents_files
               ,&contents_diretories
               ,CORN::Inclusion("*",false)
               ,CORN::OS::File_system::none_recursion_inclusive);
            CORN::OS::file_system_engine.list_DENs
               ((*template_scenario)
               ,&contents_files
               ,&contents_diretories
               ,CORN::Inclusion("*\/",false)
               ,CORN::OS::File_system::none_recursion_inclusive);
            FOR_EACH_IN(file_name,CORN::OS::File_name,contents_files,each_file)
            {  std::wstring name_with_ext;
               file_name->get_name_with_extension(name_with_ext);
               CORN::OS::File_name_concrete target_filename
                  (generate_directoryX,name_with_ext);
               CORN::OS::file_system_engine.copy_file
                  (*file_name,target_filename,false);
            } FOR_EACH_END(each_file)
            FOR_EACH_IN(dir_name,CORN::OS::Directory_name,contents_diretories,each_dir)
            {
               CORN::OS::file_system_engine.copy_directory
                  (*dir_name,generate_directoryX,false);
            } FOR_EACH_END(each_dir)
         } else
            CORN::OS::file_system_engine.copy_directory
               ((*template_scenario),generate_directoryX,false);
         */
      } else
      {  std::clog
            << "error: unable to find specified template scenario" << std::endl
            << "dir: " << value << std::endl;
         delete template_scenario;
      }
      recognized = true;
   } else if (variable == "--recognition")
   {
      scenario_level_recognition.include_from(value.c_str());
      recognized = true;
   }
   return recognized;
}
//______________________________________________________________________________
bool Scenarios_generator_engine::Arguments::get_end()
{
   // At this point we should have complied template scenario
   // so set the generate directory as CWD this will allow the
   // get_end() to discover any  seclusion files copied from the template.
   CORN::OS::file_system_engine.set_current_working_directory(generate_directory);
   return ARGUMENTS_SUPERCLASS::/*CORN::Arguments*/get_end();
}
//______________________________________________________________________________
bool Scenarios_generator_engine::Predefined_sites::provide_fields_dBase(CORN::Data_source_dBase &DBF_file)  provision_
{
   if (!/*this->*/fields_dBase)
   {
      /*this->*/geocoord_fields_dBase = fields_dBase = new Predefined_site::Fields_dBase;
   }
   return fields_dBase != 0;
}
//______________________________________________________________________________
bool Scenarios_generator_engine::Predefined_sites::setup_DBF_fields(CORN::Data_source_dBase &DBF_file)   provision_
{
   bool satup = CS::Geocoordinates::setup_DBF_fields(DBF_file);
   // Recognize either SOIL or MUKEY column
   fields_dBase->soil_MUKEY = DBF_file.lookup_field("SOIL");
   if (!fields_dBase->soil_MUKEY) fields_dBase->soil_MUKEY = DBF_file.lookup_field("MUKEY");

   fields_dBase->ID = DBF_file.lookup_field("ID");
   if (!fields_dBase->ID) fields_dBase->ID = DBF_file.lookup_field("NAME"); // Name is currently alias for ID

   // May need to  compose a list of remaining arbitrary fields

   return satup;
}
//______________________________________________________________________________
bool Scenarios_generator_engine::Predefined_sites::set_from_record
(CORN::Generic_data_record &sites_rec
,Geocoordinate &geocoord_)
{
   Predefined_site *geocoord = dynamic_cast<Predefined_site *>(&geocoord_);
   CORN::VV_section *section = sites_rec.get_current_section();
   Predefined_site::Fields_dBase *as_site_fields_dBase
      = dynamic_cast<Predefined_site::Fields_dBase *>(fields_dBase);
   if (as_site_fields_dBase->soil_MUKEY)
   {  CORN::VV_string_entry *soil_MUKEY_entry =
         dynamic_cast<CORN::VV_string_entry *>
            (section->entries.find_cstr(as_site_fields_dBase->soil_MUKEY->get_key(),false));
      if (soil_MUKEY_entry)
      {  std::string soil_MUKEY_string;
         soil_MUKEY_entry->append_to_string(soil_MUKEY_string);
         //soil_MUKEY_entry->append_to_string(site.soil_MUKEY);
      }
   }
   else if (as_site_fields_dBase->ID)
   {  CORN::VV_string_entry *ID_entry =
         dynamic_cast<CORN::VV_string_entry *>
            (section->entries.find_cstr(as_site_fields_dBase->ID->get_key(),false));
      if (ID_entry)
      {  std::string ID_string;
         ID_entry->append_to_string(ID_string);
      }
   }

   // Continue here save all other fields so we can potentially compose from them


   return Geocoordinates::set_from_record(sites_rec,geocoord_);
}
//______________________________________________________________________________
Scenarios_generator_engine::Predefined_site::Potential_scenario_element
::Potential_scenario_element(const CORN::VV_abstract_entry &item)
: CORN::Item()
, field_name      (item.get_key())
, scenario_value  ()
{
   item.append_to_string(scenario_value);
}
//______________________________________________________________________________


/*

   searches for dbf file
   or cells or points text file
   This file associates location with soil and weather
   If there is no such file (or no soil column), it is assumed all scenarios use the same soil
   If there is no such file (or no weather column) a subscenario is generated
   for each subdirectory and UED file of the Database/Weather/Scenarios

   Databases
   Recursively list all Subdirectories of the Project/Subproject databases
   Only leaf directories are listed

   Directories that match field names in the assocation file are excluded from the list.

   There may also be an exclude file to remove Database directory
   and parameter file names from composition.

   The user may have prexisting scenarios directory tree
   that identify specific sites, cropping systems, etc for hardcoded
   scenario parameter file discovery.
   These existing scenario directories will

   conceptual: Any additional generated scenario composition with have
   'generated' appended to the directory name.


*/

//______________________________________________________________________________


} // namespace CS

