//---------------------------------------------------------------------------

#pragma hdrstop


#include "SWAT_convertor.h"
//#include <common/geolocation/geolocation.h>
#include <UED/convert/station_database.h>
#include <UED/library/locrec.h>
#include <UED/library/timeqry.h>
#include <UED/library/std_codes.h>

//---------------------------------------------------------------------------
/*

VERSION 1998 
Was not Y2K compliant

Precipitation
YEAR 2 digit integer
DOY  3 digit integer
PRECIP xxx.x

Temperature
YEAR 2 digit integer
DOY  3 digit integer
Max temp  XXX.X
Min Temp  XXX.X

For mulitple stations
the Year DOY and precip or max and min temperature columns
are all repeated in 
successive columns NOT space delimited.

No title 
No geolocation headers

There was no SLR HMD WND or PET files.


Version 1999
Added 4 digit years

Precipitation
YEAR 4 digit integer
DOY  3 digit integer
PRECIP xxx.x

Temperature
YEAR 4 digit integer
DOY  3 digit integer
Max temp  XXX.X
Min Temp  XXX.X

For mulitple stations
the only the precip or max and min temperature columns
are repeated in
successive columns NOT space delimited.

No title
No geolocation headers

There was no SLR HMD WND or PET files.

Version 2000 - 2005
Appear to be fully compatible

Precipitation
YEAR 4 digit integer
DOY  3 digit integer
PRECIP xxx.x

Temperature
YEAR 4 digit integer
DOY  3 digit integer
Max temp  XXX.X    f5.1
Min Temp  XXX.X

For the remaining files only have title
and sigle datum value where datum is

.SLR Solar rad
.HUM Relative humidity
.WND Windspeed
.PET Potential ET

YEAR 4 digit integer
DOY  3 digit integer
datum XXXX.XXX   f8.3


*/
#pragma package(smart_init)
//______________________________________________________________________________


class SWAT_climate_file
//inherit from IO stream
{
protected: // options
   CORN::Ustring  title;
   CORN::Ustring  extension;
   Year           format_version_year;  // There are two formats  1998/1999 and 2000/2005
   bool           write_title;            // Is available in all version 2000/2005 files
   bool           write_geolocation;      // Geolocation data is only in precip and temperature files and only in version 2000/2005 files
   bool           write_detail;
   bool           year_4_digits;
   int            datum_width;
   int            datum_precision;
   int            datum_start_pos;
protected:
   ofstream *out_stream;
   // NYI ifstream *in_stream; // for import
   CORN::Ustring latitude_line_buffer;
   CORN::Ustring longitude_line_buffer;
   CORN::Ustring elevation_line_buffer;
   CORN::Ustring detail_line_buffer;
   CORN::Date     detail_line_date;
public:
   SWAT_climate_file
   (const char *_weather_element_description
   ,const char *_filename
   ,const char *_extension
   ,bool        _has_title
   ,bool        _has_geolocation
   ,Year        _format_version_year
   ,int         _datum_width
   ,int         _datum_precision
   );
   virtual    ~SWAT_climate_file();
   void open_output(const char *filename);
   void set_date(const CORN::Date &date);
   void set_geolocation(uint16 station_index, const UED::Geolocation_record &geolocation);
   bool record_value(int station_index, float32 value);
   bool record_maximum_minimum(int station_index, float32 maximum, float32 minimum);
};

//______________________________________________________________________________
SWAT_climate_file::SWAT_climate_file
   (const char *_weather_element_description
   ,const char *_filename
   ,const char *_extension
   ,bool        _has_title
   ,bool        _has_geolocation
   ,Year        _format_version_year
   ,int         _datum_width
   ,int         _datum_precision
   )
   : title(" SWAT climate input file format. Generated by UED import/export utility (programmer: rnelson@wsu.edu).  Data may include measured and/or estimated and/or generated data so this data should NOT be considered original source data.")
   , latitude_line_buffer  ("Lati   ")
   , longitude_line_buffer ("Long   ")
   , elevation_line_buffer ("Elev   ")
   , write_title           (_has_title)
   , write_geolocation     (_has_geolocation)
   , write_detail          (false)
   , format_version_year   (_format_version_year)
   , year_4_digits         (true)
   , datum_width           (_datum_width)
   , datum_precision       (_datum_precision)
   , datum_start_pos       (7)
   , out_stream(0)
   {
      CORN::File_name SWAT_filename (_filename,_extension);
      open_output(SWAT_filename.c_str());
      title.prepend(_weather_element_description);
      // Prior to the 2000 version these files did not have title and geolocation
      if (format_version_year < 2000)
      {  write_title         = false;
         write_geolocation   = false;
      };
      if (format_version_year < 1999)
      {  year_4_digits = false;
         datum_start_pos = 5;
      };
      detail_line_date.format
         (D_YD
         , (year_4_digits ? D_YYYY : D_YY) | D_lead_space
         ,CORN_date_NO_SEPARATOR
         ,false); // No additional DOY indicator
   };
//______________________________________________________________________________
void SWAT_climate_file::open_output(const char *filename)
{
   out_stream = new ofstream(filename);
};
SWAT_climate_file::~SWAT_climate_file()
{
   delete out_stream;
};
//______________________________________________________________________________

void SWAT_climate_file::set_date(const CORN::Date &date)
{
   if (write_title)
   {
         *out_stream << title << endl;
         write_title = false; // only write once
   };
   if (write_geolocation)
   {
      *out_stream << latitude_line_buffer << endl;
         *out_stream << longitude_line_buffer << endl;
         *out_stream << elevation_line_buffer << endl;
         write_geolocation = false; // only write once
   };

   if (write_detail) // Write a pending detail line from the previous date
         *out_stream << detail_line_buffer << endl;
   detail_line_date.set_date32(date.get());
   detail_line_buffer.assign(detail_line_date.c_str());
   write_detail = true;
};
//______________________________________________________________________________
void SWAT_climate_file::set_geolocation(uint16 station_index, const UED::Geolocation_record &geolocation)
   {
      char latititude_str[20];
      CORN_float32_to_str_formated(geolocation.get_latitude_dec_deg(), latititude_str,5, 1,'.',false);
      int latitude_pos = 7 + station_index * 5;
      latitude_line_buffer.resize(CORN_max(latitude_line_buffer.length(),latitude_pos+5));
//      latitude_line_buffer.append(latititude_str);
      latitude_line_buffer.replace(latitude_pos,5,latititude_str,0,5);
      char longitude_str[20];
      CORN_float32_to_str_formated(geolocation.get_longitude_dec_deg(),longitude_str,5, 0,'.',false);
      int longitude_pos = 7 + station_index * 5;
      longitude_line_buffer.resize(CORN_max(longitude_line_buffer.length(),longitude_pos+5));
//      longitude_line_buffer.append(longitude_str);
      longitude_line_buffer.replace(longitude_pos,5,longitude_str,0,5);
      char elevation_str[20];
      CORN_float32_to_str_formated(geolocation.get_elevation()     , elevation_str,5, 0,'.',false);
      int elevation_pos = 7 + station_index * 5;
//      elevation_line_buffer.append(elevation_str);
      elevation_line_buffer.resize(CORN_max(elevation_line_buffer.length(),elevation_pos+5));
      elevation_line_buffer.replace(elevation_pos,5,elevation_str,0,5);
/*
Precipitation Input File pcp.pcp           20080104 AVSWAT2000 - SWAT interface MDL
Lati   49.34 49.449.36           Note that columns  5 characters for each location starting in columns 8-12 (so 1 digit precision)
Long   -98.3-98.3-98.2           Note that columns  5 characters for each location starting in columns 8-12 (so 0 digit precision)
Elev     435  338  330           Note that columns  5 characters for each location starting in columns 8-12 (so 0 digit precision)
*/
   };
//______________________________________________________________________________
   bool SWAT_climate_file::record_value(int station_index, float32 value)
   {
      char value_str[20];
      CORN_float32_to_str_formated(value, value_str,datum_width,datum_precision,'.',false);
      int datum_pos = datum_start_pos + station_index * datum_width;
      detail_line_buffer.resize(CORN_max(detail_line_buffer.length(),datum_pos+datum_width));
      detail_line_buffer.replace(datum_pos,datum_width,value_str,0,datum_width);
      return true;
   };
//______________________________________________________________________________
   bool SWAT_climate_file::record_maximum_minimum(int station_index, float32 maximum, float32 minimum)
   {
      {
      char max_str[20];
      CORN_float32_to_str_formated(maximum, max_str,datum_width,datum_precision,'.',false);
      int max_pos = datum_start_pos + station_index * (datum_width*2);
      detail_line_buffer.resize(CORN_max(detail_line_buffer.length(),max_pos+datum_width));
      detail_line_buffer.replace(max_pos,datum_width,max_str,0,datum_width);
      }
      {
      char min_str[20];
      CORN_float32_to_str_formated(minimum, min_str,datum_width,datum_precision,'.',false);
      int min_pos = datum_start_pos + station_index * (datum_width*2)+ datum_width;
      detail_line_buffer.resize(CORN_max(detail_line_buffer.length(),min_pos+datum_width));
      detail_line_buffer.replace(min_pos,datum_width,min_str,0,datum_width);
      }
      // I.e:2006001000.0000.0000.0
      return true;
   };



//______________________________________________________________________________
SWAT_convertor::SWAT_convertor(int argc, const char *argv[])
:UED_convertor(argc,argv)

{ };
//______________________________________________________________________________

/*NYI SWAT_subdaily preciptation is not yet implemente

int record
   void set minute of the day ()  this will be converted to hour and minute of the hour

*/
//______________________________________________________________________________
#ifdef NYI
uint32 SWAT_convertor::perform_import()
{
   weather_data_validator = station_database->provide_weather_data_validator();

      Quality temperature_min_smart_quality(measured_quality);
      temperature_min_smart_quality.set(weather_data_validator->validate(doy,temperature_min,min_temperature_creation.variable_code,temperature_min_units,UT_day,CORN::measured_quality,CORN::measured_quality));

};
#endif
//______________________________________________________________________________
uint32 SWAT_convertor::perform_export()
{
   uint32 records_exported = 0;

   // provide each of the listed UED_filenames.
   // This format allows export of multiple weather station in a single file
   setup_stations_from_response_UED_filenames();

   CORN::Date export_start_date;
   CORN::Date export_end_date;

   bool determine_available_UED_date_ranges =
      (   is_essentially(parameters.date_time_earliest,0.0,0.0000001)
       || is_essentially(parameters.date_time_latest,0.0,0.0000001)
       || (parameters.year_earliest == 0)
       || (parameters.year_latest   == 0));

   Datetime64 earliest_encountered_date=9999999;
   Datetime64 lastest_encountered_date=0;
   if (determine_available_UED_date_ranges)
   {  // get the earliest and latest dates of all of the UED files
      FOR_EACH_IN(station_database,Station_database, station_databases,each_station_DB)
      {
         Datetime64 earliest_UED_file_date = station_database->ued_file.get_earliest_date_time(UED_FOR_ALL_RECORD_TYPES,UED_FOR_ALL_VARIABLES);
         Datetime64 lastest_UED_file_date  = station_database->ued_file.get_latest_date_time  (UED_FOR_ALL_RECORD_TYPES,UED_FOR_ALL_VARIABLES);
         earliest_encountered_date = std::min<float64>(earliest_encountered_date,earliest_UED_file_date);
         lastest_encountered_date =  std::max<float64>(lastest_encountered_date ,lastest_UED_file_date);
      } FOR_EACH_END(each_station_DB)
      export_start_date.set_datetime64(earliest_encountered_date);
      export_end_date  .set_datetime64(lastest_encountered_date);
   };

   if  (parameters.year_earliest== 0)
   {  // then set it to the earliest date encountered
      export_start_date.set_datetime64(earliest_encountered_date);
   } else
      export_start_date.set_YD(parameters.year_earliest,1);

   if (parameters.year_latest >= 9999)
   { // then set it to the latest date encountered
      export_end_date  .set_datetime64(lastest_encountered_date);
   } else
   {  export_end_date.set_YD(parameters. year_latest + 1,1);
      export_end_date.dec(); // (to get Dec31).
   };

   int SWAT_format_year = atoi(parameters.subformat.c_str());
   SWAT_climate_file TMP_file("Daily temperature (°C Maximum Minimum)"  ,parameters.target_filename.c_str(),"tmp",true,true ,SWAT_format_year ,5,1);
   SWAT_climate_file PCP_file("Daily precipitation (mm)"                ,parameters.target_filename.c_str(),"pcp",true,true ,SWAT_format_year,5,1);
   SWAT_climate_file SLR_file("Daily solar radiation (MJ/m²)"           ,parameters.target_filename.c_str(),"slr",true,false,SWAT_format_year,8,3);
   SWAT_climate_file HMD_file("Daily relative humidity (% average)"     ,parameters.target_filename.c_str(),"hmd",true,false,SWAT_format_year,8,3);
   SWAT_climate_file WND_file("Daily wind speed (m/s)"                  ,parameters.target_filename.c_str(),"wnd",true,false,SWAT_format_year,8,3);
   SWAT_climate_file PET_file("Potential evapotranspiration (mm)"       ,parameters.target_filename.c_str(),"pet",true,false,SWAT_format_year,8,3);

   uint16 station_index = 0; // as of 2005 SWAT allows up to 300 records(stations) in one file (actually limited to 150 in the temperature but more than this should be rare)
   FOR_EACH_IN(station_database,Station_database, station_databases,each_station_DB)
   {
      const UED::Geolocation_record *geolocation = station_database->ued_file.get_geolocation_record_immutable();
      if (geolocation)
      {
         TMP_file.set_geolocation(station_index,*geolocation);
         PCP_file.set_geolocation(station_index,*geolocation);
         SLR_file.set_geolocation(station_index,*geolocation);
         HMD_file.set_geolocation(station_index,*geolocation);
         WND_file.set_geolocation(station_index,*geolocation);
         PET_file.set_geolocation(station_index,*geolocation);
      };

      station_index++;
   } FOR_EACH_END(each_station_DB);


   // Daily file generation
   for (CORN::Date record_date(export_start_date.get_date32()); record_date <= export_end_date.get_date32(); record_date.inc())
   { // for each of the dates to be recorded
      uint16 station_index = 0; // as of 2005 SWAT allows up to 300 records(stations) in one file (actually limited to 150 in the temperature but more than this should be rare)

      cout << '\r' << record_date.c_str() << ":";
      TMP_file.set_date(record_date);
      PCP_file.set_date(record_date);
      SLR_file.set_date(record_date);
      HMD_file.set_date(record_date);
      WND_file.set_date(record_date);
      PET_file.set_date(record_date);
      UED::Time_query_single_date time_qry(record_date.get_datetime64());

      FOR_EACH_IN(station_database,Station_database, station_databases,each_station_DB)
      {
         UED::Database_file_indexed &UED_file = station_database->ued_file;
         cout << ' ' <<  station_database->get_key();
         {  // Max temperature
            Units_code temperature_max_units = UC_celcius;
            Quality_code temperature_max_quality = unknown_quality;
            float32 temperature_max    = UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_max_temperature.get(),time_qry,temperature_max_units,temperature_max_quality);

            if (!is_valid_quality(temperature_max_quality))
               temperature_max = -99.0; // SWAT invalid indicator
            // Min temperature
            Units_code temperature_min_units = UC_celcius;
            Quality_code temperature_min_quality;
            float32 temperature_min    = UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_min_temperature.get(),time_qry,temperature_min_units,temperature_min_quality);
            if (!is_valid_quality(temperature_min_quality))
               temperature_min = -99.0; // SWAT invalid indicator
            TMP_file.record_maximum_minimum(station_index,temperature_max,temperature_min);
         }
         { // Precipitation temperature
            Units_code precipitation_units = UC_mm;
            Quality_code precipitation_quality = unknown_quality;
            float32 precipitation      =UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_precipitation.get(),time_qry,precipitation_units,precipitation_quality);
            if (!is_valid_quality(precipitation_quality))
               precipitation = -99.0; // SWAT invalid indicator
            PCP_file.record_value(station_index,precipitation);
         }
         { // Solar radiation temperature
            Units_code solar_rad_units = UC_MJ_m2;
            Quality_code solar_rad_quality = unknown_quality;
            float32 solar_radiation    =UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_solar_radiation.get(),time_qry,solar_rad_units,solar_rad_quality);
            if (!is_valid_quality(solar_rad_quality))
               solar_radiation = -99.0; // SWAT invalid indicator
            SLR_file.record_value(station_index,solar_radiation);
         }
         { // Relative humidity
            Units_code rel_humid_units = UC_percent;
            Quality_code rel_humid_quality = unknown_quality;
            float32 avg_relative       =UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_avg_relative_humidity.get(),time_qry,rel_humid_units,rel_humid_quality);
            if (!is_valid_quality(rel_humid_quality))
               avg_relative = -99.0; // SWAT invalid indicator
            HMD_file.record_value(station_index,avg_relative);
         }
         { // Wind speed
            Units_code wind_speed_units = UC_meters_per_second;
            Quality_code windspeed_smart_quality = unknown_quality;
            float32 wind_speed         =UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_wind_speed.get(),time_qry,wind_speed_units,windspeed_smart_quality);
            if (!is_valid_quality(windspeed_smart_quality))
               wind_speed = -99.0; // SWAT invalid indicator
            WND_file.record_value(station_index,wind_speed);
         }
         { // ET pot
            Units_code ETpot_units = UC_mm;

            // First see if there is measured ETpot (maybe measured, othersize generate),
            // if not, then see if there is penman-monteith (probably generated)
            // if not, then see if there is priestly-taylor (probably generated)
            // if not, then see if there is hargreaves      (probably generated)
            Quality_code                                   ETpot_quality = unknown_quality; float32 ETpot =UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_pot_evapotranspiration.get(),time_qry,ETpot_units,ETpot_quality);
            if       (!is_valid_quality(ETpot_quality))  { ETpot_quality = unknown_quality;         ETpot =UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_ref_ET_Penman_Monteith.get(),time_qry,ETpot_units,ETpot_quality);
               if    (!is_valid_quality(ETpot_quality))  { ETpot_quality = unknown_quality;         ETpot =UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_ref_ET_Priestly_Taylor.get(),time_qry,ETpot_units,ETpot_quality);
                  if (!is_valid_quality(ETpot_quality))  { ETpot_quality = unknown_quality;         ETpot =UED_file.get_no_create(UED::Record_type_distinguisher_interface::UED_data_set_year_var_units,UED::STD_VC_ref_ET_Hargreaves.get()     ,time_qry,ETpot_units,ETpot_quality);
            }  }  };
            if (!is_valid_quality(ETpot_quality))
               ETpot = -99.0; // SWAT invalid indicator
            PET_file.record_value(station_index,ETpot);
         }
         station_index++;
      } FOR_EACH_END(each_station_DB)
      records_exported ++;
   };
   cout << endl;
/*NYI  Subdaily precipitation option
   if (precipitation_time_step)
   from date_time_earliest date/time to date_time_latest date/time step timestep
   {


   };
*/

   return records_exported;
};
//______________________________________________________________________________

