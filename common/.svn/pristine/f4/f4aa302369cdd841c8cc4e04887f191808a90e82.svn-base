#  include "UED/library/UED.h"
#  include "UED/library/std_codes.h"
#  include "common/weather/wthrbase.h"
#  include "common/weather/database/weather_database.h"
/* No longer used
#  include "corn/math/statistical/stats_best.h"
*/
#  include "common/weather/loc_param.h"
#  include "common/weather/any_timestep/min_max_to_timestep_estimator.h"
#  include "common/weather/atmospheric_CO2_change.h"

#  ifndef compareHPP
#     include "corn/math/compare.hpp"
#  endif

#ifdef WEATHER_GENERATION
#include "ClimGen/source/ClimGenF.h"
#endif

#include <assert.h>
#ifdef DETAIL_TRACE
#include <fstream>
using namespace std;
extern int trace_indent;
extern std::ofstream trace;
//extern std::ofstream dump;
bool dump_it = true;
#endif

#define get_now() today
//150125 eventually replace get_now() with today
// get_now was when Sun was the temporal driver
//______________________________________________________________________________
Weather_base::Weather_base
(Weather_database    *weather_database_                                          //050307
,modifiable_ Weather_provider &provider_                                         //151201
,const CORN::Date_const &today_                                                  //150125
,const Geocoordinate &geocoordinate_                                             //150629
,float64              screening_height                                           //151128
//151201 moved to meteorology   ,const CS::Solar_irradiance_extraterrestrial /*151028 _daily*/ &ET_solar_irradiance_new_     //150626
,bool                 treat_valid_data_as_real_                                  //081108
,bool                 read_only_                                                 //000711
//160110 snow_pack has been moved to Land_unit_meteorology ,Snow_pack_model      snow_pack_model_                                           //991004
//160110 snow_pack has been moved to Land_unit_meteorology ,float64              soil_slope_percent_                                        //991004
//160110 snow_pack has been moved to Land_unit_meteorology ,float64              site_aspect_deg_from_north_                                //991004
//160110 snow_pack has been moved to Land_unit_meteorology ,bool                 forest_vegetation_                                         //991004
,CORN::Seconds)      /*unused time_step_seconds may be used in derived classes need to check*/ // 000711
: Weather_interface()                                                            //151027
//151027 moved to Land_unit_meteorology , Xsun(today_,geocoordinate_)                                                     //151027
/* moved to Land_unit_meteorological
, Xsky //151027 Sky
   (
   //151027 UC_MJ_m2,*_weather_database->get_geolocation_constant()
   //151037 ,_today               //150125_020319
    ET_solar_irradiance_new_                                                     //150626
   ,curr_air_temperature_avg  //151027 air_temperature_avg                                                          //151023
   ,curr_solar_radiation      //151027 solar_radiation                                                              //151023
   ,curr_precipitation        //151027 precipitation
   )                                                               //151023
*/
//151201 #if ((CS_VERSION>=1) && (CS_VERSION<=4))
//151201 ,Wind(curr_wind_speed,2.0)                                                       //150209
//151201#endif
,CS::Weather_subdaily                                                            //151212
   (*this //weather_database_
   ,today_
   ,provider_.air_temperature_max
   ,provider_.air_temperature_min
   ,provider_.relative_humidity_max
   ,provider_.relative_humidity_min
   )
#if ((CS_VERSION>=1) && (CS_VERSION<=4))
,Wind(provider_.wind_speed,2.0)                                                  //151202_150209
#endif
,CS::Seasons
   (today_
   ,(geocoordinate_.get_latitude_dec_deg() < 0)                                  //150629
   )
,provider(provider_)                                                             //151201
,database_read_only        (read_only_)                                          //010726
,treat_valid_data_as_real  (treat_valid_data_as_real_)                           //081109
,geocoordinate             (geocoordinate_)                                      //151027
,weather_data              (weather_database_)                                   //050307
,avg_DOY_with_min_annual_temperature(15)                                         //060427
,updated_for_year          (0)                                                   //130515
,annual_temperature_avg    (0)                                                   //130515

,ClimGen_parameters(0)                                                           //091214
{
   //010726			get_end() will be called after we load the location parameters
   //					but I now also allow a default location with default weather
   //					parameters but with a weather filename (specified in constructor)
   //					so call get_end() now to load that weather database with
   //					simple snow pack model.
}
//_1999-03-01___________________________________________________________________
Weather_base::~Weather_base()
{  // We can't delete the abstract class, it doesn't call the virtual destructor!
   weather_data = 0; // just a reference pointer, don't delete                   //041130
}
//_2000-07-10___________________________________________________________________
bool Weather_base::done_with_dates_before(const CORN::Date_const &earliest_date) const
{  return weather_data->done_with_dates_before(earliest_date);
}
//_2014-11-03___________________________________________________________________
#if (CS_VERSION < 5)
const Location_parameters *Weather_base::get_location_parameters() const // 090303 made const
{  return weather_data->get_location_parameters();}
#endif
//_2005-07-13___________________________________________________________________
const Geolocation         *Weather_base::get_geolocation_constant() const
{return weather_data->get_geolocation_constant();}                               //050713
//_2005-05-25___________________________________________________________________
const CORN::Quality &Weather_base::load_wind_speed_estimate_if_necessary
(Wind_speed &wind_speed,const Date_const *_date)
{
//160706 #ifdef WEATHER_PROVIDER_VERSION
   assert(false); // NYI
/*
#else
   if (_date.get() == 0) _date.set(today.get_date32());
   float64 WS_m_s = load_wind_speed(wind_speed,_date);
   if (WS_m_s < 0.00001) wind_speed.invalidate();
   if (!wind_speed.is_valid())
   {
      float64 WS_m_d = forecast_wind_speed_m_d(_date.get_DOY());
      wind_speed.set_m_d(WS_m_d,quality_forecasted_from(CORN::estimated_quality));//150811
      // Note that forcasted from is worse quality generated
      // This will allow ClimGen's generated wind speed to
      // override this forecast from seasonal conditions
   }
#endif
*/
   return wind_speed;
}
//_2015-01-26__1997-03-03_______________load_wind_speed_estimate_if_necessary__/
float64 Weather_base::forecast_wind_speed_m_d(CORN::DOY doy)
{  float64 result = 0.0;
   const Location_parameters *location = weather_data->get_location_parameters(); // 090303 made const
   switch (location?location->wind_speed_classification_labeled.get():WIND_SPEED_MEDIUM )
   {  case WIND_SPEED_UNKNOWN    : result = 0.0; break;                           //091217
      case WIND_SPEED_VERY_LOW   : result = 1.0; break; // m/s                    //980311
      case WIND_SPEED_LOW        : result = 2.0; break; // m/s                    //980311
      case WIND_SPEED_MEDIUM     : result = 3.0; break; // m/s                    //980311
      case WIND_SPEED_MEDIUM_HIGH: result = 4.0; break; // m/s                    //980311
      case WIND_SPEED_HIGH       : result = 6.0; break; // m/s                    //980311
      case WIND_SPEED_VERY_HIGH  : result = 8.0; break; // m/s                    //980311
      case WIND_SPEED_SPECIFIED  :
         {  // Don't need to check location exists here (done above)
             result =
               is_spring_or_summer_time(doy)                                     //140813
               ? location->get_wind_speed_spring_summer_ms() // m/s
               : location->get_wind_speed_fall_winter_ms() ; // m/s
         } break;
   }
   result *= seconds_per_day;  // convert m/s -> m/d
   result = CORN::must_be_greater_or_equal_to<float64>(result,0.0001);           //980710
   return result;
}
//_1997-03-03___________________________________________________________________
/*151118 Now takes reference to gecoordinate which might not necessarity be the weather data location.
float64 Weather_base::get_location_elevation_m()   const { return weather_data->get_geolocation_constant()->get_elevation();}
float64 Weather_base::get_latitude_dec_deg()       const { return weather_data->get_geolocation_constant()->get_latitude_dec_deg(); } // degrees
float64 Weather_base::get_longitude_dec_deg()      const { return weather_data->get_geolocation_constant()->get_longitude_dec_deg(); }
float64 Weather_base::get_latitude_rad()           const { return weather_data->get_geolocation_constant()->get_latitude_radians();}  // radians
float64 Weather_base::get_longitude_rad()          const { return weather_data->get_geolocation_constant()->get_longitude_radians();}
*/
//______________________________________________________________________________
const char *Weather_base::get_description(std::string &return_buffer)    const
{ return weather_data->get_description(return_buffer); }                         //050525
//_2004-11-09_________________________________________________get_description__/
void Weather_base::load()
{
   // load the data for the time step

   weather_data->get_to(provider);
   if (treat_valid_data_as_real)                                                                                                                   //081109
   {
      // Now using assume quality because we don't want to mark the property as modified, otherwise a new record may be instanciated               //141101

      if (provider.precipitation_actual          .get_quality()            .is_valid())   provider.precipitation_actual   .assume_code(measured_quality);
      if (provider.solar_radiation        .get_quality()            .is_valid())   provider.solar_radiation .assume_code(measured_quality);     //081109
      if (provider.wind_speed             .get_quality()            .is_valid())   provider.wind_speed      .assume_code(measured_quality);     //081109
      if (curr_max_temperature            .get_quality().is_valid())   curr_max_temperature                    .assume_code(measured_quality);  //081109
      if (curr_min_temperature            .get_quality().is_valid())   curr_min_temperature                    .assume_code(measured_quality);  //081109
      if (curr_max_dew_point_temperature  .get_quality().is_valid())   curr_max_dew_point_temperature          .assume_code(measured_quality);  //081109
      if (curr_min_dew_point_temperature  .get_quality().is_valid())   curr_min_dew_point_temperature          .assume_code(measured_quality);  //081109
      if (curr_avg_dew_point_temperature  .get_quality().is_valid())   curr_avg_dew_point_temperature          .assume_code(measured_quality);  //081109
      if (curr_max_relative_humidity      .get_quality().is_valid())   curr_max_relative_humidity              .assume_code(measured_quality);  //081109
      if (curr_min_relative_humidity      .get_quality().is_valid())   curr_min_relative_humidity              .assume_code(measured_quality);  //081109
   }
}
//_______________________________________________________________________load__/
bool Weather_base::start_day()
{  bool started = true;                                                          //150126
   /*180201 didnt do anything anymore
   invalidate(true); // Clear completely all values from previous day.           //091218
   */
   load();
   started &= update();                                                          //150126
   /*180201 didnt do anything anymore
   if (ClimGen_parameters) // When generating in ClimGen we want to clear any previous generated element values   //091216
      invalidate(false);   // don't invalidate optimal (I.e. measured, calculate, interpolated) values.  //091216
   */
   started &= CS::Weather_subdaily::start_day(); // do last because needs loaded weather
   return started;                                                               //150125_140709
}
//_2009-12-16_______________________________________________________start_day__/
bool Weather_base::update()                                       /* should be  rectification_*/ //151212
{  bool updated = true;

   // Probably should call sky.update() here, but need to check
   // if where I have it now is needed there.

//050604       curr_max_vapor_pressure_deficit requires dewpt and rel humidity
//             see if we can get atleast estimated values
   //   curr_max_relative_humidity and curr_min_dew_point_temperature now both can be calculated
   //   from VPD_max (aridity factor) and Tmax I am updating curr_max_vapor_pressure_deficit_kPa first
   //   so it will be ready for use by curr_max_relative_humidity and  curr_min_relative_humidity.
   //  This is kind of a hack doing this here, I should use a provide idiom.      081016

//TRACE trace << get_now().get_year() << ' ' << doy ;
//TRACE trace << "\t Tmax = " << get_curr_max_temperature();
//TRACE trace << "\t Tmin = " << get_curr_min_temperature();
//TRACE trace << endl;

//if (dump_it)
//{
//dump  <<  get_now().get_year() << ' ' << doy << '\t' << get_curr_max_temperature() << '\t' << get_curr_min_temperature();
//}

   //151202 curr_vapor_pressure_nighttime.know_DOY_unused(doy);                                  //081030_
   // Update minimum relative humidity first because
   // it has the most stable estimation
   // and we need it first if we need to use the regression parameters
   // to produce vapor_pressure_minimum.

   season_S_S_F_W=(Season_S_S_F_W)get_season_S_S_F_W();                          //050801

   #if ((CS_VERSION>=1) && (CS_VERSION<=4))
      Wind::update_aerodynamic_resistance();
   #endif

   provider.aerodynamics.update();                                         //110104
   updated &= CS::Weather_subdaily::update();                                    //151212
   return updated;                                                               //140709
}
//_1999-10-08__________________________________________________________update__/

//          In the following load methods, the quality request will be any valid quality
//          The load with return the actual quality

bool Weather_base::load_weather_provider(Weather_provider &weather_provider) mutation_
{  return weather_data->get_to(weather_provider);

   //110910 Note probably should set up treat_valid_data_as_real
   // as in load(), but this wasn't previously done,
   // so carefully check where needed
   // for example, see where Daily::get_solar_radiation(const CORN::Date  & _date)
   // is used

}
//_2011-09-10___________________________________________________________________
/* //160706
#else

//______________________________________________________________________________
#ifdef NYI
float64 Weather_base::load_curr_pot_evapotranspiration_m()             mutation_
{
   pot_evapotranspiration_quality = UED_valid_attribute;                         //990802
   return curr_pot_evapotranspiration_m = load_pot_evapotranspiration_m(pot_evapotranspiration_quality,today);
}
//______________________________________________________________________________
float64 Weather_base::load_curr_vapor_pressure_deficit_kPa()           mutation_
{  vapor_pressure_deficit_quality = UED_valid_attribute;                         //990802
   return curr_vapor_pressure_deficit_kPa = load_pot_vapor_pressure_deficit_kPa(pot_vapor_pressure_deficit_quality,today);
}
#endif
//______________________________________________________________________________
float64 Weather_base::load_curr_solar_radiation()  mutation_// yes only pass by value!
{  return load_solar_radiation(curr_solar_radiation,today);                      //140715_990802
}
//_1997-10-13___________________________________________________________________
float64 Weather_base::load_curr_precipitation()                        mutation_
{ return load_precipitation               (curr_precipitation              , today); } //151027
float64 Weather_base::load_curr_max_temperature()                      mutation_
{  return load_max_temperature            (curr_max_temperature            ,today);} //050602
float64 Weather_base::load_curr_min_temperature()                      mutation_
{  return load_min_temperature            (curr_min_temperature            ,today);} //050602
float64 Weather_base::load_curr_avg_dew_point_temperature()            mutation_ // yes only pass by value!                //050602
{  return load_avg_dew_point_temperature  (curr_avg_dew_point_temperature  ,today);} //050602
float64 Weather_base::load_curr_min_dew_point_temperature()             mutation_ // yes only pass by value!                //980305
{  return load_min_dew_point_temperature  (curr_min_dew_point_temperature  ,today);} //050602
float64 Weather_base::load_curr_max_dew_point_temperature()             mutation_ // yes only pass by value!                //980305
{  return load_max_dew_point_temperature  (curr_max_dew_point_temperature  ,today);} //050602
float64 Weather_base::load_curr_max_relative_humidity( )                mutation_ //  %
{  return load_max_relative_humidity      (curr_max_relative_humidity      ,today);} //050602
float64 Weather_base::load_curr_min_relative_humidity()                 mutation_ // yes only pass by value!                    //980306
{return  load_min_relative_humidity      (curr_min_relative_humidity  ,today);}      //050602
float64 Weather_base::load_curr_avg_fullday_vapor_pressure_deficit_kPa() mutation_ // yes only pass by value!   //080617
{ return  load_avg_fullday_VPD_kPa(curr_avg_fullday_vapor_pressure_deficit,today);}                                                                     //080617
//______________________________________________________________________________
float64 Weather_base::load_curr_wind_speed_m_d()                       mutation_
{
   const Geolocation *geoloc = weather_data ? weather_data->get_geolocation_constant() : 0; //150427
   Wind_speed parameter
      (geoloc ? geoloc->get_screening_height() : 2.0);                           //150427
   parameter.assume_code(UED_give_me_best_quality);
   load_wind_speed(parameter,today);
   return parameter.get_m_d();
}
//_2015-01-23__1998-04-23_______________________________________________________
float64 Weather_base::load_solar_radiation(Solar_radiation &solar_rad, const Date_time  &date_time_) mutation_
{  float64 result = 0.0;
   if (weather_data)
      result = weather_data->get_solar_radiation(solar_rad,date_time_);
   else solar_rad.invalidate(true);                                              //021211
   // don't change quality for this type of load, the date may not be the current date  040510
   return result;                                                                //150123
}
//_2014-07-15___________________________________________________________________
float64 Weather_base::load_precipitation
(Precipitation &parameter, const Date_time  &date_time_ ) mutation_
{
float64 result = 0.0;
   if (weather_data)
   {
      result = weather_data->get_precipitation_m(parameter,date_time_);
      parameter.force_amount(result);                                            //151028
      //parameter.assume(quality);                                                 //151028
   }
   else parameter.invalidate(true);                                              //021211
   // don't change quality for this type of load, the date may not be the current date  040510
   return result;
}
//______________________________________________________________________________
#ifdef NYI
float64 Weather_base::load_pot_evapotranspiration_m(Weather_daily_load_formals) mutation_ // yes only pass by value!
{  float64 result = 0.0;
   if (weather_data)
     result =  weather_data->get_pot_evapotranspiration_m(quality,_date_time);
   else quality |= not_valid_quality;
   xxxxx_quality = quality;
   return result;
}
//______________________________________________________________________________
float64 Weather_base::load_min_temperature(Air_temperature_minimum &parameter, const Date_time  &_date_time) mutation_ // yes only pass by value!
{  float64 result = 0.0;
   if (weather_data)
   {  CORN::Quality_clad quality;
      result = weather_data->get_min_temperature(quality,_date_time);
      parameter.force_amount(result);                                            //150123
      parameter.assume(quality);                                                 //150123
   }
   else parameter.invalidate(true);                                              //021211
   //040510_ don't change quality for this type of load, the date may not be the current date
   return result;                                                                //150123
}
//______________________________________________________________________________
float64 Weather_base::load_min_relative_humidity(Relative_humidity &parameter,  const Date_time  &_date_time) mutation_  // yes only pass by value!
{  float64 result = 0.0;
   if (weather_data)
   {  CORN::Quality_clad quality;
      result =  weather_data->get_min_relative_humidity(quality,_date_time);
      parameter.force_amount(result);                                            //150123
      parameter.assume(quality);                                                 //150123
   } else parameter.invalidate(true);                                            //021211
   // don't change quality for this type of load, the date may not be the current date 040510
   return result;                                                                //150123
}
//_1998-03-06___________________________________________________________________
float64 Weather_base::load_avg_fullday_VPD_kPa
(Vapor_pressure_deficit_fullday &parameter
,  const Date_time  &_date_time)                                       mutation_ // yes only pass by value!
{  float64 result = 0.0;
   if (weather_data)
   {  CORN::Quality_clad quality;
      result =  weather_data->get_avg_fullday_vapor_pressure_deficit_kPa(quality,_date_time);
      parameter.force_amount(result);                                            //150123
      parameter.assume(quality);                                                 //150123
   } else parameter.invalidate(true);                                            //021211
   // don't change quality for this type of load, the date may not be the current date 040510_
   return result;                                                                //150123
}
//_2008-06-17_____________________________________________________________________________
float64 Weather_base::load_max_relative_humidity(Relative_humidity &parameter, const Date_time  &_date_time ) mutation_  //  %
{  float64 result = 0.0;
   if (weather_data)
   {  CORN::Quality_clad quality;
      result = weather_data->get_max_relative_humidity(quality,_date_time);
      parameter.force_amount(result);                                            //150123
      parameter.assume(quality);                                                 //150123
   } else parameter.invalidate(true);                                            //021211
   // don't change quality for this type of load, the date may not be the current date 040510
   return result;                                                                //150123
}
//______________________________________________________________________________
float64 Weather_base::load_max_dew_point_temperature(Dew_point_temperature_maximum &parameter, const Date_time  &_date_time)  mutation_// yes only pass by value!
{  float64 result = 0.0;
   if (weather_data)
   {  CORN::Quality_clad quality;
      result = weather_data->get_max_dew_point_temperature(quality,_date_time);
      parameter.force_amount(result);                                            //150123
      parameter.assume(quality);                                                 //150123
   } else parameter.invalidate(true) ;                                           //021211
   //040510_ don't change quality for this type of load, the date may not be the current date
   return result;                                                                //150123
}
//_1998-03-05____________________________________________________________________
float64 Weather_base::load_min_dew_point_temperature(Dew_point_temperature_minimum &parameter, const Date_time  &_date_time)  mutation_// yes only pass by value!
{  float64 result = 0.0;
   if (weather_data)
   {  CORN::Quality_clad quality;
     result = weather_data->get_min_dew_point_temperature(quality,_date_time);
      parameter.force_amount(result);                                            //150123
      parameter.assume(quality);                                                 //150123
   }  else parameter.invalidate(true);                                           //021211
   // don't change quality for this type of load, the date may not be the current date  040510
   return result;                                                                //150123
}
//_1998-03-05____________________________________________________________________
float64 Weather_base::load_avg_dew_point_temperature(Dew_point_temperature_average &parameter, const Date_time  &_date_time)  mutation_
{  float64 result = 0.0;
   if (weather_data)
   {  CORN::Quality_clad quality;
     result = weather_data->get_avg_dew_point_temperature(quality,_date_time);
      parameter.force_amount(result);                                            //150123
      parameter.assume(quality);                                                 //150123
   } else parameter.invalidate(true) ;                                //021211
   //040510_ don't change quality for this type of load, the date may not be the current date
   return result;                                                                //150123
}
//_1998-03-05____________________________________________________________________
float64 Weather_base::load_wind_speed(Wind_speed &parameter , const Date_time  &_date_time)  mutation_ //150123
{  float64 result = 0.0;
   if (weather_data)
   {  CORN::Quality_clad quality;
      result =  weather_data->get_wind_speed_m_d(quality,_date_time);
      result = parameter.set_m_d(result,quality);                                //150123
   } else parameter.invalidate(true);                                            //021211
   // don't change quality for this type of load, the date may not be the current date  040510
   return result;
}
#endif
*/
//_1998094023___________________________________________________________________
/*151023
float64 Weather_base::precipitate()        // returns liquid total water entering the system
{  return snow_pack->precipitate();
}
*/
//______________________________________________________________________________
/* 160706 #ifdef WEATHER_PROVIDER_VERSION

#else
float64 Weather_base::set_precipitation_mm
(float64 precip_mm
,CORN::Quality &attribute)
{
   return curr_precipitation.update_value_qualified(weather_data->set_precipitation_mm(get_now(),precip_mm,attribute),attribute); //151027
}
//_1999-04-24___________________________________________________________________
float64 Weather_base::set_pot_evapotranspiration_mm
(float64 pot_ET_mm
,CORN::Quality &attribute)
{  curr_pot_evapotranspiration_m = mm_to_m(weather_data->set_pot_evapotranspiration_mm(get_now(),pot_ET_mm,attribute));   //990827
   pot_evapotranspiration_quality.assume(attribute);
   return curr_pot_evapotranspiration_m;                                        //990827
}
//_1999-11-09___________________________________________________________________
float64 Weather_base::set_avg_fullday_vapor_pressure_deficit_kPa
(float64 avg_VPD_kPa
,CORN::Quality &attribute)
{  return curr_avg_fullday_vapor_pressure_deficit.update_value_qualified
   (weather_data->set_avg_fullday_vapor_pressure_deficit_kPa(get_now(),avg_VPD_kPa,attribute),attribute);  //080617
}
//_1999-11-09___________________________________________________________________
float64 Weather_base::set_max_temperature
(float64 degrees_C
,CORN::Quality & attribute
,bool override_safety)                                                           //081115
{  return  curr_max_temperature.update_value_qualified(weather_data->set_max_temperature(get_now(),degrees_C,attribute),attribute, override_safety);   //050603
}
//_1999-04-24___________________________________________________________________
float64 Weather_base::set_min_temperature
(float64 degrees_C
,CORN::Quality & attribute
,bool override_safety)                                                           //081115
{  return curr_min_temperature.update_value_qualified(weather_data->set_min_temperature(get_now(),degrees_C,attribute),attribute, override_safety); //990827
}
//_1999-04-24___________________________________________________________________
float64 Weather_base::set_solar_radiation
(float64 solar_rad_MJ_m2
,CORN::Quality & attribute)                                             mutation_
{
   return curr_solar_radiation.set_MJ_m2                                         //140715
      (weather_data->set_solar_radiation(get_now(),solar_rad_MJ_m2,attribute)
      ,attribute);                                                               //990827
}
//_1999-04-24___________________________________________________________________
float64 Weather_base::set_max_relative_humidity
(float64 max_rel_humid_percent
,CORN::Quality & attribute)
{return curr_max_relative_humidity.update_value_qualified(weather_data->set_max_relative_humidity(get_now(),max_rel_humid_percent,attribute),attribute); }  //990827
//150123 { return curr_max_relative_humidity.set(weather_data->set_max_relative_humidity(get_now(),max_rel_humid_percent,attribute),attribute); }  //990827
//_1999-04-24___________________________________________________________________
float64 Weather_base::set_min_relative_humidity
(float64 min_rel_humid_percent
,CORN::Quality & attribute)
{  return curr_min_relative_humidity.update_value_qualified(weather_data->set_min_relative_humidity(get_now(),min_rel_humid_percent,attribute),attribute);   //990827
}
//_1999-04-24___________________________________________________________________
float64 Weather_base::set_max_dew_point_temperature
(float64 max_dew_point_temp
,CORN::Quality & attribute)
{  return curr_max_dew_point_temperature.update_value_qualified(weather_data->set_max_dew_point_temperature(get_now(),max_dew_point_temp,attribute),attribute);
}
//_1999-04-24___________________________________________________________________
float64 Weather_base::set_min_dew_point_temperature
(float64 min_dew_point_temp
,CORN::Quality & attribute)
{  return curr_min_dew_point_temperature.update_value_qualified(weather_data->set_min_dew_point_temperature(get_now(),min_dew_point_temp,attribute),attribute); //050603
}
//_1999-04-24___________________________________________________________________
float64 Weather_base::set_avg_dew_point_temperature
(float64 avg_dew_point_temp
,CORN::Quality & attribute)
{  return curr_avg_dew_point_temperature.update_value_qualified(weather_data->set_avg_dew_point_temperature(get_now(),avg_dew_point_temp,attribute),attribute); //050603
}
//_1999-04-24___________________________________________________________________
float64 Weather_base::set_wind_speed_m_d
(float64 wind_speed_m_d
,CORN::Quality & attribute)
{
   //150123 Warning  I most likely need to use update_value_qualified
   curr_wind_speed.update_value_qualified(weather_data->set_wind_speed_m_d(get_now(),wind_speed_m_d,attribute), attribute); //150123
   return curr_wind_speed.get_m_d(); //return value is the specified units
}
#endif
*/
//_1999-04-24___________________________________________________________________
void Weather_base::commit( const Date_const &now)
{  // Save any modifications (Call this before advancing to the next timestep).

   if (curr_max_temperature.is_modified()
   ||curr_min_temperature.is_modified()
   ||curr_max_relative_humidity.is_modified()
   ||curr_min_relative_humidity.is_modified()
   ||curr_max_dew_point_temperature.is_modified()
   ||curr_min_dew_point_temperature.is_modified())
      weather_data->set_from(provider);
}
//_2005-06-16___________________________________________________________________
void Weather_base::fix_up_relative_humidity()
{  //CORN::Quality_clad curr_max_relative_humidity_quality(curr_max_relative_humidity.get_quality());
   float32 max_rel_humid = curr_max_relative_humidity.percent();
   //CORN::Quality_clad curr_min_relative_humidity_quality(curr_min_relative_humidity.get_quality());
   float32 min_rel_humid = curr_min_relative_humidity.percent();
   if (max_rel_humid < min_rel_humid)
   {
      float32 hold =  min_rel_humid;
      min_rel_humid = max_rel_humid;
      max_rel_humid = hold;
      curr_max_relative_humidity.force_amount(max_rel_humid);
      curr_min_relative_humidity.force_amount(min_rel_humid);
   }
}

bool Weather_base::any_valid_data_today()
{  return
      get_precipitation_quality()            .is_valid()
   || get_max_temperature_quality()          .is_valid()
   || get_min_temperature_quality()          .is_valid()
   || curr_solar_radiation                   .is_valid()                         //140715
   || get_max_dew_point_temperature_quality().is_valid()
   || get_min_dew_point_temperature_quality().is_valid()
   || get_max_relative_humidity_quality()    .is_valid()
   || get_min_relative_humidity_quality()    .is_valid();
}
//______________________________________________________________________________
/*151212 moved to Weather_subdaily
Minutes Weather_base::get_minutes_in(Units_code time_step_units) const
{  Minutes minutes_in_timestep=60;
   switch (time_step_units)
   {  case UT_minute  : minutes_in_timestep = 1;   break;
      case UT_hour    : minutes_in_timestep = 60;  break;
      default :
      {  CORN::Units_clad smart_time_step(time_step_units);
         CORN::Units_component time_step_component(smart_time_step.get_primary());
         switch (time_step_component.get_measure_index())
         {
            case UM_minutes: minutes_in_timestep = time_step_component.get_submeasure_index(); break;
            case UM_hours  : minutes_in_timestep = 60.0 * time_step_component.get_submeasure_index(); break;
         }
      } break;
   }
   return minutes_in_timestep;
}
//______________________________________________________________________________
float64 Weather_base::Time_step_variable_estimator::get_at(nat32 interval) const
{  return curr_values.get(interval); }
//______________________________________________________________________________
void  Weather_base::get_temperature_by_interval
(Units_code time_step_units,Dynamic_array<float32>&temperature_X_minute)
{  Time_step_variable_estimator *timestep_estimator = get_temperature_time_step_estimator(time_step_units);
   timestep_estimator->estimator->get_by_interval(temperature_X_minute);
}
//_2004-11-15___________________________________________________________________
float64 Weather_base::get_est_temperature_at(Units_code time_step_units,uint16 time_index) const
{  Time_step_variable_estimator *timestep_estimator = get_temperature_time_step_estimator(time_step_units);
   float64 temperature = timestep_estimator->get_at(time_index);
   return temperature;
}
//_2004-11-15___________________________________________________________________
float64 Weather_base::get_est_temperature_at_hour(Hour hour) const
{  return get_est_temperature_at(UT_hour,hour);
}
//_2005-008-16__________________________________________________________________
Weather_base::Time_step_variable_estimator::Time_step_variable_estimator(Units_code _time_step_units,Min_max_to_timestep_estimator *_estimator)
: Enumeration()
, estimator(_estimator)                                                          //060501
, curr_values(_estimator->get_intervals(),24,0.0)                                //060501
, time_step_units(_time_step_units)
{}
//_2004-11-15___________________________________________________________________
Weather_base::Time_step_variable_estimator::~Time_step_variable_estimator()
{  delete estimator; }
//_2004-11-15___________________________________________________________________
Weather_base::Time_step_variable_estimator
   *Weather_base::get_temperature_time_step_estimator(Units_code time_step_units) mutation_
{  Time_step_variable_estimator *time_step_estimator
   = (Time_step_variable_estimator *)time_step_temperature_estimators.find((uint32)time_step_units);
   if (!time_step_estimator)
   {  // There has not be a request for estimation at this time step yet so create one.
      Temperature_estimator * estimator = new Temperature_estimator(get_minutes_in(time_step_units));
      #ifdef WEATHER_PROVIDER_VERSION
      weather_data->get_parameter_on
         (Tmin_tomorrow,UED::STD_VC_min_temperature.get(),provided_date_tomorrow);     //151126
      float64 tmin_tomorrow_Celcius = Tmin_tomorrow.Celcius();                   //151126
      weather_data->get_parameter_on
         (Tmax_yesterday,UED::STD_VC_max_temperature.get(),provided_date_yesterday);   //151126
      float64 tmax_yesterday_Celcius = Tmax_yesterday.Celcius();                 //151126
      #else
      float64 tmin_tomorrow_Celcius = get_next_min_temperature();                //060511
      CORN::Date yesterday(today); yesterday.dec_day(1);                         //060511
      float64 tmax_yesterday_Celcius = get_max_temperature(yesterday);           //060511
      #endif
      estimator->reset
            (curr_max_temperature.Celcius()
            ,tmax_yesterday_Celcius
            ,curr_min_temperature.Celcius()
            ,tmin_tomorrow_Celcius);
      time_step_estimator = new Time_step_variable_estimator(time_step_units,estimator);
      time_step_temperature_estimators.append(time_step_estimator);
   }
   return time_step_estimator;
}
//_2004-11-15___________________________________________________________________
Weather_base::Time_step_variable_estimator *Weather_base::get_relative_humidity_time_step_estimator(Units_code time_step_units) mutation_
{  Time_step_variable_estimator *time_step_estimator
   = (Time_step_variable_estimator *)time_step_relative_humidity_estimators.find((uint32)time_step_units);
   if (!time_step_estimator)
   {  // There has not be a request for estimation at this time step yet so create one.
      Relative_humidity_estimator * estimator = new Relative_humidity_estimator(get_minutes_in(time_step_units));
      float64 RHmax = curr_max_relative_humidity.percent();              //150126_081106
      float64 RHmin = curr_min_relative_humidity.percent();              //150126_081106
      estimator->reset
            (RHmax  // max today
            ,RHmax  // actually normally we want max_tomorrow
            ,RHmin   // min today
            ,RHmin); // actually normally we want min_yesterday
      time_step_estimator = new Time_step_variable_estimator(time_step_units,estimator);  //060511
      time_step_relative_humidity_estimators.append(time_step_estimator);
   }
   return time_step_estimator;
}
//_2004-11-15___________________________________________________________________
*/
/*151027 Caller should now instead take reference to Sky
float64 Weather_base::get_shortwave_net_radiation_today_MJ_m2(float64 _albedo) const
{  // needs units indicator I think return MJ_m2
   float64 sol_rad_MJ_m2 = curr_solar_radiation.get_MJ_m2();                     //140715
   float64 short_wave_net_rad = Xsky.calc_shortwave_net_radiation(_albedo,sol_rad_MJ_m2);
   return short_wave_net_rad;
}
*/
//_2004-11-08___________________________________________________________________
/*150626
float64 Weather_base::get_extraterrestrial_irradiance_today_MJ_m2() const
{  // currently we derive from Solar_irradinces as M2/m2
   return get_extraterrestrial_irradiance_today();
}
*/
//_2004-11-09___________________________________________________________________
float64 Weather_base::get_curr_max_air_temperature()                       const {return curr_max_temperature;}     //LML 140916
float64 Weather_base::get_air_temperature_min_tomorrow()                   const
{
   return Tmin_tomorrow;
}
//_2015-12-01___________________________________________________________________
float64 Weather_base::get_air_temperature_max_yesterday()                  const
{  return Tmax_yesterday;
}
//_2015-12-01___________________________________________________________________
#ifdef WEATHER_GENERATION
void Weather_base::know_generation_parameters(const ClimGen_Parameters  &_ClimGen_parameters) contribution_
{  ClimGen_parameters = &_ClimGen_parameters;
   curr_vapor_pressure_nighttime.know_generation_parameters(_ClimGen_parameters.vapor_pressure_nighttime_parameters);
   curr_max_vapor_pressure_deficit.know_generation_parameters(_ClimGen_parameters.VPD_parameters);
   curr_max_relative_humidity.know_generation_parameters(_ClimGen_parameters.relative_humidity_extremes,season_for_dew_point);
   curr_min_relative_humidity.know_generation_parameters(_ClimGen_parameters.relative_humidity_extremes,season_for_dew_point);
}
//_2009-12-14___________________________________________________________________
#endif
//______________________________________________________________________________
CORN::date32 Weather_base::get_earliest_available_date()                   const //150209
{  return weather_data->get_earliest_available_date();
}
//_2014-02-09___________________________________________________________________
//#ifdef WEATHER_PROVIDER_VERSION
// Actually this can be all versions
bool Weather_base::get_parameter_on
(modifiable_ CS::Parameter  &property
,nat32                       variable_code // Typically the variable code will be UED variable code
,const CORN::Date_const     &on_date)                             rectification_
{
   return weather_data->get_parameter_on(property,variable_code,on_date);
}
//_2015-11-22___________________________________________________________________
/*151122 conceptual
bool Weather_base::setup_property_reference
(Physical::Property_cowl  &property
,nat32                     variable_code // Typically the variable code will be UED variable code
,const CORN::Date         &on_date)                               rectification_
{
   return weather_data->setup_property_reference(property,variable_code,on_date);
}
*/
//_2015-11-19___________________________________________________________________*

//#endif
/*decided not to do this
 const Air_temperature_average *Weather_base::provide_air_temperature_average_on(const CORN::Date &on_date) provision_
{
   assert(false);//NYI
   return 0;
}
//_2015-11-19___________________________________________________________________*
const Air_temperature_maximum *Weather_base::provide_air_temperature_maximum_on(const CORN::Date  &date) provision_
{
}
//_2015-11-19___________________________________________________________________
const Air_temperature_minimum *Weather_base::provide_air_temperature_minimum_on(const CORN::Date  &date) provision_
{
}
//_2015-11-19___________________________________________________________________
const Precipitation           *Weather_base::provide_precipitation_on(const CORN::Date  &date) provision_
{
   assert(false);//NYI
   return 0;
}
*/
//_2015-11-19___________________________________________________________________

//060613 1157 lines
//090707  973 lines

