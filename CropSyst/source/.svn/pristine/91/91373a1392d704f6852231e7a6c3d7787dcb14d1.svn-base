// Chemical profile for soil
#  include <math.h>
#  include "corn/math/moremath.h"
#  include "soil/chemical_balance.h"
#  include "soil/chemical_profile.h"
#  include "soil/chemical_mass_profile.h"
#  include "soil/chemicals_profile.h"
#  include "soil/nitrogen_profile.h"
#  include "soil/soil_base.h"
#  include "watertab.h"
#  include "static_phrases.h"
#include "common/chemistry/stoichiometry_composition.h"

#include "physics_constants.h"
#define SPACER 0
#ifndef compareHPP
#  include "corn/math/compare.hpp"
#endif
#define HAVE_ELEMENTAL_FORM

// Only for debugging
//ofstream Nconc_dump ("N_conc.dat");

//______________________________________________________________________________
float32 XUa[6] = {SPACER, -1.28,-0.525,0.0,0.525,1.28};
// These variables are currently global until I can find a better place for them
//______________________________________________________________________________
Chemical_pool::Chemical_pool
(const std::string          &chem_name                                           //001116
,float64                _chem_to_element_factor
,float64                _element_to_chem_factor
#if (CROPSYST_VERSION == 4)
,float64                _control_transformation_adjustment
#endif
,soil_layer_array64     (_simulation_amount_E)                                   //051120
   // For NO3 and NH4 this is mass for salt, this is concentration in dSm
,const Soil_layers_interface               &_soil_layers                         //150925
,const Soil_hydrology_interface            &_soil_hydrology                      //150925
,const Soil_hydraulic_properties_interface &_soil_hydraulic_properties           //150925
,const Soil_structure_interface            &_soil_structure                      //150925
,Infiltration_model      infiltration_model                                      //080117
)
:name(chem_name)
,soil_layers              (_soil_layers)                                         //150925
,soil_hydrology           (_soil_hydrology)                                      //150925
,soil_hydraulic_properties(_soil_hydraulic_properties)                           //150925
,soil_structure           (_soil_structure)                                      //150925
,chem_to_element_factor(_chem_to_element_factor)
,element_to_chem_factor(_element_to_chem_factor)
#if (CROPSYST_VERSION == 4)
,control_transformation_adjustment(_control_transformation_adjustment)
#endif
,profile_transformed_from_M(1.0)                                                 //010317
,ANNL_bal_accums(0)                                                              //990316
,GP_bal_accums_current(0)                                                        //990316
,CONT_bal_accums  (0)                                                            //990316
#if (REACCH_VERSION < 2)
,FALLOW_bal_accums(0)                                                            //990316
#endif
{
   soil_layer_array64(amount_M); //kg chem / m^2 soil molecular
      // rename this to M_mass_layer
   for (int sublayer_clear = 0; sublayer_clear <= MAX_soil_sublayers ; sublayer_clear++)  //981006
   {  amount_M[sublayer_clear] = 0.0;                                            //981007
      transformed_from_M[sublayer_clear] = 0; // transformed from something else //981007
   }                                                                             //981007
   nat8 soil_num_sublayers = soil_layers.get_number_layers();
   for (int layer = 1; layer <= soil_num_sublayers; layer ++)
   {  float64 amount_E_sl = _simulation_amount_E[layer];                         //020305
      {  float64 amount_chem_sl  = element_to_chem_factor
            * (per_ha_to_per_m2(amount_E_sl));                                   //981212
         amount_M[layer] = amount_chem_sl;
      }
   }
   #ifdef FINITE_DIFF
   if (infiltration_model == FINITE_DIFFERENCE_INFILTRATION)                     //080116
   {  Chemical_mass_profile_node_based *mass_nodal = new Chemical_mass_profile_node_based(soil_layers);
      mass_nodal->initialize(amount_M);
      mass = mass_nodal;
   } else
   #endif
   {  Chemical_mass_profile_layer_based *mass_layered = new Chemical_mass_profile_layer_based(soil_layers);
      mass_layered->initialize(amount_M);
      mass = mass_layered;
   }
}
//______________________________________________________________________________
Chemical_pool::~Chemical_pool()
{  if (mass) delete mass; mass = 0;
}
//_2008-01-16___________________________________________________________________

void Chemical_pool::instanciate_accumulators()                     //contribution_
{  float64 original_profile_content_M = get_current_profile_content_M();
   ANNL_bal_accums = new Chemical_balance_accumulators
   (original_profile_content_M,name,get_transformation_name(),chem_to_element_factor,has_uptake());
  GP_bal_accums_current = new Chemical_balance_accumulators
  (original_profile_content_M,name,get_transformation_name(),chem_to_element_factor,has_uptake());
  CONT_bal_accums = new Chemical_balance_accumulators
  (original_profile_content_M,name,get_transformation_name(),chem_to_element_factor,has_uptake());
#if (REACCH_VERSION < 2)
//HACK: Currently we have always activated these reporters, but I want to just have the accumulators
// and report only as necessary
  FALLOW_bal_accums = new Chemical_balance_accumulators
  (original_profile_content_M,name,get_transformation_name(),chem_to_element_factor,has_uptake());
#endif
}
//_2011-11-07__1999-03-19_______________________________________________________
//160309 #if ((REACCH_VERSION<2) || defined(_DEBUG))
void Chemical_pool::update_YLY_bal_reporter()
{    if (ANNL_bal_accums) delete ANNL_bal_accums;
     ANNL_bal_accums= new Chemical_balance_accumulators
     (get_current_profile_content_M(),name,get_transformation_name(),chem_to_element_factor,has_uptake());
}
//1650309 #endif
//_1999-03-19___________________________________________________________________
Chemical_profile::Chemical_profile
(const std::string &chem_name                                                        //001116
,chemical_types _chemical_type
,float64 _chem_to_element_factor
,float64 _element_to_chem_factor
#if (CROPSYST_VERSION==4)
,float64 _control_transformation_adjustment
#endif
,soil_layer_array64(_simulation_amount_E)                                        //051120
,const Soil_layers_interface               &_soil_layers                         //150925
,const Soil_hydrology_interface            &_soil_hydrology                      //150925
,const Soil_hydraulic_properties_interface &_soil_hydraulic_properties           //150925
,const Soil_structure_interface            &_soil_structure                      //150925
,Infiltration_model infiltration_model                                           //080117
,Water_table_curve *_water_table_curve                                           //000504
)
:Chemical_pool
   (chem_name
   ,_chem_to_element_factor
   ,_element_to_chem_factor
   #if (CROPSYST_VERSION==4)
   ,_control_transformation_adjustment
   #endif
   ,_simulation_amount_E
   //150925 ,_soil                                                                        //060503
   ,_soil_layers
   ,_soil_hydrology
   ,_soil_hydraulic_properties
   ,_soil_structure
   ,infiltration_model)
,chemical_type(_chemical_type)
#ifdef WATERTABLE
,water_table_curve(_water_table_curve)                                           //000504
,water_table_concentration(0.0)                                                  //071218
#endif
,reported_leached_molecular(0.0)
,balance_leached_molecular(0.0)
,surface_mass_pending_infiltration_M(0)                                          //071214
,start_application_time(0)                                                       //081212
,reliquish_rate_mass_M_per_sec(0)                                                //080307
,daily_requirements(0.0)
,total_requirements(0.0)                                                         //010416
,applied_irrig_soil_M(0.0)
,nu(0.6)                                                                         //080606
{
//NYI #ifdef OLD_IRR_CHEM_APPL
//NYI #else
//NYI /*090724_*/    for (Hour hour = 0; hour < 24; hour++)
//NYI /*090724_*/       surface_mass_pending_infiltration_M_hour[hour] = 0.0;
//NYI #endif
}
//______________________________________________________________________________
Chemical_profile::~Chemical_profile()
{
#ifdef WATERTABLE
   if (water_table_curve) delete water_table_curve;
#endif
}
//_2000-05-04___________________________________________________________________
Chemical_uptake_profile::Chemical_uptake_profile
(const std::string          &chem_name
,chemical_types         _chemical_type
,float64                _chem_to_element_factor
,float64                _element_to_chem_factor
#if (CROPSYST_VERSION==4)
,float64                _control_transformation_adjustment
#endif
,soil_layer_array64     (_simulation_amount_E)                                //051120
,const Soil_layers_interface               &_soil_layers                         //150925
,const Soil_hydrology_interface            &_soil_hydrology                      //150925
,const Soil_hydraulic_properties_interface &_soil_hydraulic_properties           //150925
,const Soil_structure_interface            &_soil_structure                      //150925
,Infiltration_model      _infiltration_model                                  //080117
,Water_table_curve      *_water_table_curve                                   //000504
)
: Chemical_profile(chem_name
   ,_chemical_type
   ,_chem_to_element_factor
   ,_element_to_chem_factor
   #if (CROPSYST_VERSION==4)
   ,_control_transformation_adjustment
   #endif
   ,_simulation_amount_E
   ,_soil_layers
   ,_soil_hydrology
   ,_soil_hydraulic_properties
   ,_soil_structure
   ,_infiltration_model                                                          //080117
   ,_water_table_curve)                                                          //000504
,check_unused_uptake_molecular(0)
{}
//______________________________________________________________________________
float64 Chemical_uptake_profile::uptake_elemental
(nat8 layer, float64 requested_elemental_N_uptake)
{
   float64 elemental_amount_available = chem_to_element_factor*
      mass->get_layer(layer);
   float64 actual_N_uptake = (requested_elemental_N_uptake > elemental_amount_available)
      ? elemental_amount_available
      : requested_elemental_N_uptake;

//130911 Warning I am not sure why I am not incrementing the uptakes because
//this is called for each layer and uptake would be cumulative for the profile!!!

   float64 uptake_molecular  = element_to_chem_factor*(actual_N_uptake) ;        //130911
   mass->dec_layer(layer,uptake_molecular);                                      //080117
   if (ANNL_bal_accums)       ANNL_bal_accums   ->inc_uptake(uptake_molecular);          //990317
   if (GP_bal_accums_current) GP_bal_accums_current     ->inc_uptake(uptake_molecular);  //990317
   if (CONT_bal_accums)       CONT_bal_accums   ->inc_uptake(uptake_molecular);          //990317
#if (REACCH_VERSION < 2)
   if (FALLOW_bal_accums)     FALLOW_bal_accums ->inc_uptake(uptake_molecular);          //990317
#endif
   return  actual_N_uptake;
}
//_1998-07-03_____________________________________________________________________________
#ifdef NOT_YET_IMPLEMENTED
potassium_profile.initialize()                                   initialization_
{  Chemical_uptake_profile.initialize
      (chem_name,_kind
      ,_control_transformation_adjustment
      ,simulation_amount_E,layer_divisions,soil_num_sublayers,soil_in_layer_of);
   constantC = 800.0;
   constantQ = 0.008;
}
//______________________________________________________________________________
phosphorus_profile.initialize()                       initialization_
{  Chemical_uptake_profile.initialize(chem_name,_kind,
     _control_transformation_adjustment,simulation_amount_E,layer_divisions,soil_num_sublayers,soil_in_layer_of);
      constantC = 300000.0;
      constantQ = 0.0002;
}
#endif
//______________________________________________________________________________
void Chemical_profile::update_balance_pending_infiltration()
{
   if (ANNL_bal_accums)       ANNL_bal_accums      ->know_pending_infiltration(surface_mass_pending_infiltration_M); //990317
   if (GP_bal_accums_current) GP_bal_accums_current->know_pending_infiltration(surface_mass_pending_infiltration_M); //070801
   if (CONT_bal_accums)       CONT_bal_accums      ->know_pending_infiltration(surface_mass_pending_infiltration_M); //990317
   #if (REACCH_VERSION < 2)
   if (FALLOW_bal_accums)     FALLOW_bal_accums    ->know_pending_infiltration(surface_mass_pending_infiltration_M); //990317
   #endif
}
//_2007-10-16___________________________________________________________________
void Chemical_profile::inc_applied(float64 addition_M)
{
   if (addition_M != 0)                                                          //120704
   {
      if (ANNL_bal_accums)    ANNL_bal_accums   ->inc_applied(addition_M);
      if (GP_bal_accums_current) GP_bal_accums_current->inc_applied(addition_M); //070801
      if (CONT_bal_accums)    CONT_bal_accums   ->inc_applied(addition_M);
      #if (REACCH_VERSION < 2)
      if (FALLOW_bal_accums)  FALLOW_bal_accums ->inc_applied(addition_M);
      #endif
   }
}
//_1999-03-17____________________________________________________________________
void Chemical_profile::inc_applied_irrig_soil(float64 addition_M)
{  if (addition_M != 0.0)                                                        //120704
   {  applied_irrig_soil_M += addition_M;
      if (ANNL_bal_accums)    ANNL_bal_accums   ->inc_applied_irrig_soil(addition_M);
      if (GP_bal_accums_current) GP_bal_accums_current->inc_applied_irrig_soil(addition_M);
      if (CONT_bal_accums)    CONT_bal_accums   ->inc_applied_irrig_soil(addition_M);
      #if ( REACCH_VERSION < 2)
      if (FALLOW_bal_accums)  FALLOW_bal_accums ->inc_applied_irrig_soil(addition_M);
      #endif
   }
}
//_1999-03-17____________________________________________________________________
void Chemical_profile::inc_applied_and_applied_irrig_soil_subsurface(float64 addition_M)
{  inc_applied(addition_M);
   inc_applied_irrig_soil(addition_M);
}
//_1999-03-17____________________________________________________________________
void Chemical_profile::inc_applied_and_applied_irrig_soil_surface
 (float64 addition_M
 ,Hour    start_application_hour                                                 //081212
 ,Hours   event_duration)
{
   if (addition_M > 0.000001)                                                                         //071214
   {                                                                                                  //071214
      surface_mass_pending_infiltration_M += addition_M;                                              //080307
      float64 reliquish_rate_mass_M_per_sec_this_application = addition_M / (event_duration * 3600);  //080307

//090721 Warning: There may be a problem when multiple chemical application events occur
// in the same day, It may be necessary to have pending M from application for each hour

//NYI #ifdef OLD_IRR_CHEM_APPL
      start_application_time = start_application_hour * seconds_per_hour;        //081212
      reliquish_rate_mass_M_per_sec += reliquish_rate_mass_M_per_sec_this_application; //080307
//NYI #else
//NYI /*090722_*/       for (Hour hour_offset = 0; hour_offset < event_duration; hour_offset++)
//NYI /*090722_*/       {  Hour application_hour = start_application_hour + hour_offset;
//NYI /*090722_*/          surface_mass_pending_infiltration_M_hour[application_hour] += reliquish_rate_mass_M_per_sec_this_application * 3600;
//NYI /*090722_*/       }
//NYI #endif
      update_balance_pending_infiltration();                                     //071016
      inc_applied(addition_M);
      inc_applied_irrig_soil(addition_M);
   }
}
//_1999-03-17____________________________________________________________________
void Chemical_profile::application
(float64 addition
,nat8 layer
,nat8 split_into_layers
,nat8 soil_num_layers
,bool is_elemental)
{  float64 addition_M = (is_elemental)
      ? element_to_chem_factor*(addition)
      : addition;
   // If there are not enough sublayers for the desired splitting,}
   // determine a splitting that will work;                            }
   while (split_into_layers > (soil_num_layers - layer + 1))
       split_into_layers--;
   for (nat8 split = 0; split < split_into_layers; split++)
   {  float64 split_amount = addition_M / split_into_layers;                     //080117
      mass->inc_layer(layer+split,split_amount);                                 //080117
   }
   mass->commit_diffs();                                                         //120731
   inc_applied_and_applied_irrig_soil_subsurface(addition_M);                    //990317
}
//_1993-03-01?__________________________________________________________________
void Chemical_profile::application_at_layer
(float64 addition
,nat8 at_layer
,bool is_elemental)
{  float64 addition_M = (is_elemental)
      ? element_to_chem_factor*(addition)
      : addition;
   // If there are not enough sublayers for the desired splitting,}
   // determine a splitting that will work;                            }
   mass->inc_layer(at_layer,addition_M);
   mass->commit_diffs();
   inc_applied_and_applied_irrig_soil_subsurface(addition_M);
}
//_2016-01-20___________________________________________________________________
void Chemical_profile::application_concentration
(float64 addition_concentration , float64 irrigation ) // kg/m3<- need convert to molecular in caller
{  float64 addition_M = addition_concentration * irrigation;
   inc_applied_and_applied_irrig_soil_subsurface(addition_M);
}
//_1999-03-17____________________________________________________________________
#ifdef WATERTABLE
float64 Chemical_profile::get_water_table_concentration(/*150925 const CORN::Date &today*/)
{  // For some chemical profiles, water table is not considered.
   float64 water_table_conc = (water_table_curve)
   ? water_table_curve->get_for_today()                                                             //150925
     // already in concentration * 0.64
   : 0.0;
   return  water_table_conc;
}
//______________________________________________________________________________
bool Chemical_profile::adjust_water_table_concentration
(
//150925 const CORN::Date &today,
nat8 number_FD_soluation_layers
,nat8 number_of_real_plus_extended_layers)
{  water_table_concentration = get_water_table_concentration()/*150925 (today)*/;             //000504
   float64 water_table_mass_input = 0.0;
   for (nat8 layer = number_FD_soluation_layers+2 /*2 is top_inundated_layer?*/
         // 080219 RLN not sure why not from the top inundated layers
       ; layer <= number_of_real_plus_extended_layers-1; layer++)                //080218
   {  float64 layer_thickness_m = soil_layers.get_thickness_m(layer);
      float64 sat_WC_layer = soil_hydraulic_properties.get_saturation_water_content_volumetric(layer,ICE_WATER_CONTENT_RELEVENCE_UNKNOWN_140822);
      float64 before_inundation_layer_mass = mass->get_layer(layer);
      float64 inundated_layer_mass = water_table_concentration * sat_WC_layer * layer_thickness_m;
      mass->set_layer(layer,inundated_layer_mass);
      water_table_mass_input += (before_inundation_layer_mass - inundated_layer_mass);
   }
   mass->commit_diffs();                                                         //120731
   inc_balance_leached_M(water_table_mass_input); // Simply treat any watertable innundation as immediate upflow.
   return true;
}
//_2007-12-14____________________________________________________________________
#endif
float64   Chemical_profile::relinquish_surface_mass_pending_infiltration_M(Seconds at_time,Seconds duration) modification_
{  float64 surface_mass_pending_infiltration_M_relinquished = 0.0;
   //NYI #ifdef OLD_IRR_CHEM_APPL
   if (at_time >= start_application_time)                                        //081212
   {  float64 mass_M_relinquish_now = duration * reliquish_rate_mass_M_per_sec;                    //080308
      surface_mass_pending_infiltration_M_relinquished = mass_M_relinquish_now;                    //080308
      if (mass_M_relinquish_now >= surface_mass_pending_infiltration_M )                           //080308
      {  // This case shouldn't really occur but there may be residual amount;                     //080308
         surface_mass_pending_infiltration_M_relinquished = surface_mass_pending_infiltration_M;   //080308
         surface_mass_pending_infiltration_M = 0.0;                                                //080308
         reliquish_rate_mass_M_per_sec = 0;                                                        //080308
      } else                                                                                       //080308
      {  surface_mass_pending_infiltration_M -= surface_mass_pending_infiltration_M_relinquished;  //080308
      }                                                                                           //080308
   }
//NYI #else
//NYI /*090722_*/    Hour from_hour = at_time / 3600;         // Note I should prorate this for times and durations that are part of an hour, but currently times and durations at full hours, and in any case, I dont think it is much an issue
//NYI /*090722_*/    Hour to_hour   = (at_time + duration) / 3600;
//NYI /*090722_*/    for (Hour hour = from_hour; hour <= to_hour; hour++)
//NYI /*090722_*/    {  surface_mass_pending_infiltration_M_relinquished += surface_mass_pending_infiltration_M_hour[hour];
//NYI /*090722_*/       surface_mass_pending_infiltration_M -= surface_mass_pending_infiltration_M_hour[hour];
//NYI /*090722_*/       surface_mass_pending_infiltration_M_hour[hour] = 0;
//NYI /*090722_*/    }
//NYI #endif
   return surface_mass_pending_infiltration_M_relinquished;
}
//______________________________________________________________________________
void Chemical_profile::resolution_of_Thomas_agorithm
(nat8 num_slots_eff    // This will be either the number of layers or nodes
,soil_node_array64(a_term)    // layer or nodal array
,soil_node_array64(b_term)    // layer or nodal array
,soil_node_array64(c_term)    // layer or nodal array
,soil_node_array64(d_term)    // layer or nodal array
,soil_node_array64(new_water_depth_slotal)
,soil_layer_array64(slot_concentration)
,soil_node_array64(sorbed_chemical_mass) // layer or nodal array                 //080606
,soil_layer_array64(slot_chemical_mass))                                         //080606
{
   // Resolution of the system by Thomas algorithm. New concentration computation
   // Soil Physics with BASIC Pg 35 (G.S. Campbell)                              //071220
   // This code works with either layer or nodal systems
   // the term 'slot' is used to refer to layer or node
#ifdef _DEBUG
soil_node_array64(DEBUG_d_term_E);   clear_node_array64(DEBUG_d_term_E); // for debugging only
soil_node_array64(DEBUG_chemical_conc_E); clear_node_array64(DEBUG_chemical_conc_E);
soil_node_array64(DEBUG_chemical_mass_slot_E); clear_node_array64(DEBUG_chemical_mass_slot_E); // only for debugging
#endif
   for (nat8 slot = 1; slot <=  (num_slots_eff - 1) ; slot++)                    //For Layer = 1 To (Number_Of_Soil_Layers - 1)
   {  //' Condition added to avoid division by 0
       if (CORN::is_approximately<float64>(b_term[slot],0.0,0.0000001))          //If B_Term(Layer) = 0 Then B_Term(Layer) = 0.0000000001  //080114
           b_term[slot] = 0.0000000001;                                                                                                                            //080114
       // Condition added to avoid division by 0
       // (may occur in completely frozen soil layer).
       c_term[slot] /= b_term[slot];                                             //    C_Term(Layer) = C_Term(Layer) / B_Term(Layer)
       d_term[slot] /= b_term[slot];                                             //    D_Term(Layer) = D_Term(Layer) / B_Term(Layer)
       b_term[slot+1] -= a_term[slot+1] * c_term[slot];                          //    B_Term(Layer + 1) = B_Term(Layer + 1) - A_Term(Layer + 1) * C_Term(Layer)
       d_term[slot+1] -= a_term[slot+1] * d_term[slot];                          //    D_Term(Layer + 1) = D_Term(Layer + 1) - A_Term(Layer + 1) * D_Term(Layer)
       // This is added by RLN to avoid slightly negative numbers
       // This is not in the V.B. version but probably should be.
       if (CORN::is_approximately<float64>(a_term[slot],0.0,0.0000000000001)) a_term[slot] = 0.0;
       if (CORN::is_approximately<float64>(b_term[slot],0.0,0.0000000000001)) b_term[slot] = 0.0;
       if (CORN::is_approximately<float64>(c_term[slot],0.0,0.0000000000001)) c_term[slot] = 0.0;
       if (CORN::is_approximately<float64>(d_term[slot],0.0,0.0000000000001)) d_term[slot] = 0.0;
#ifdef _DEBUG
DEBUG_d_term_E[slot] = d_term[slot] *  chem_to_element_factor;  // This simply for debugging to view values in elemental
DEBUG_chemical_conc_E[slot] =  slot_concentration[slot] *  chem_to_element_factor;
#endif
  }                                                                                   //Next Layer
  if (CORN::is_approximately<float64>(b_term[num_slots_eff],0.0,0.0000001))            //If B_Term(Number_Of_Soil_Layers) = 0 Then B_Term(Number_Of_Soil_Layers) = 0.0000000001         //080114
      b_term[num_slots_eff] = 0.0000000001; // Again check for div0                    //' Condition added to avoid division by 0                                                       //080114
   soil_node_array64(new_slot_concentration); clear_node_array64(new_slot_concentration);                                                                                               //070924
   // for last effective node
   new_slot_concentration[num_slots_eff]                                               //New_Layer_Concentration(Number_Of_Soil_Layers) = D_Term(Number_Of_Soil_Layers) / B_Term(Number_Of_Soil_Layers)
      = d_term[num_slots_eff] / b_term[num_slots_eff];
   slot_concentration[num_slots_eff] = new_slot_concentration[num_slots_eff]; // 080114 Added by RLN wasn't in V.B. code
   slot_chemical_mass[num_slots_eff]                                                   //Layer_Chemical_Mass(Number_Of_Soil_Layers) = Sorbed_Chemical_Mass(Number_Of_Soil_Layers) _                //080114
      = sorbed_chemical_mass[num_slots_eff]                                                                                                                                                        //080114
      + new_slot_concentration[num_slots_eff] * new_water_depth_slotal[num_slots_eff];  //                + New_Layer_Concentration(Number_Of_Soil_Layers) * New_Water_Depth(Number_Of_Soil_Layers)//080114
#ifdef _DEBUG
DEBUG_chemical_conc_E[num_slots_eff] =  slot_concentration[num_slots_eff] *  chem_to_element_factor;
DEBUG_chemical_mass_slot_E[num_slots_eff] = slot_chemical_mass[num_slots_eff] * chem_to_element_factor;  // debug only
#endif
   for (nat8 slot = (num_slots_eff - 1); slot >= 1; slot --)                          //For Layer = (Number_Of_Soil_Layers - 1) To 1 Step -1                           //990109
   {  new_slot_concentration[slot]                                                     //    New_Layer_Concentration(Layer)  _
         = d_term[slot] - c_term[slot] * new_slot_concentration[slot+1];               //         = D_Term(Layer) - C_Term(Layer) * New_Layer_Concentration(Layer + 1)
      slot_concentration[slot] = new_slot_concentration[slot];                         //    Layer_Concentration(Layer) = New_Layer_Concentration(Layer)                //080114
      slot_chemical_mass[slot]                                                         //    Layer_Chemical_Mass(Layer)  _                                              //080114
         = sorbed_chemical_mass[slot]                                                  //        = Sorbed_Chemical_Mass(Layer) _                                        //080114
         + new_slot_concentration[slot] * new_water_depth_slotal[slot];                 //                + New_Layer_Concentration(Layer) * New_Water_Depth(Layer)     //080114
#ifdef _DEBUG
DEBUG_chemical_conc_E[slot] =  slot_concentration[slot] *  chem_to_element_factor;
DEBUG_chemical_mass_slot_E[slot] = slot_chemical_mass[slot] * chem_to_element_factor;  // debug only
#endif

   }                                                                                  //Next Layer
   // Determination of leaching and mass balance check is done by the caller
}
//_2008-06-06_________________________resolution_of_Thomas_agorithm_and_update_/
void Chemical_profile::transport_unidirectional_4_11_03
(nat8 num_layers_eff
,soil_layer_array64(flow)  // m3 water/m2 soil (m water depth)   flow out of the layer
,soil_layer_array64(old_liquid_water_content)
,soil_layer_array64(new_liquid_water_content)
,float64 water_entering
,Seconds                at_time
,Seconds                duration // seconds of duration
,bool override_drainage_depth
,nat8 drainage_sublayer)
{ // This should work with any timestep - RLN
                                                                                       // (Fertigation As Double
                                                                                       // , Daily_Time_Step As Boolean
                                                                                       // , HourlyCascade As HourlyCascadeClass, _
                                                                                       // DailyCascade As DailyCascadeClass
                                                                                       // , Soil As SoilClass)
                                                                                       //
                                                                                       // Dim Layer As Integer
                                                                                       // 'Dim Layer As Integer
                                                                                       // Dim Flow(mmax) As Double
                                                                                       // 'Dim Layer_Chemical_Mass(mmax) As Double
   soil_layer_array64(layer_concentration);     clear_layer_array64(layer_concentration); // concentration of chemical in water kg/m3 // Dim Layer_Concentration(mmax) As Double //070924
   soil_layer_array64(sorbed_chemical_mass);    clear_layer_array64(sorbed_chemical_mass); // Dim Sorbed_Chemical_Mass(mmax) As Double //070924
   soil_layer_array64(bypass_chemical_mass);    clear_layer_array64(bypass_chemical_mass); // Dim Sorbed_Chemical_Mass(mmax) As Double //081001
                                                                                       // 'Dim Lower_Water_Content(mmax) As Double
                                                                                       // 'Dim Upper_Water_Content(mmax) As Double
                                                                                       // Dim Layer_Thickness As Double
                                                                                       // Dim Previous_Layer_Thickness As Double
                                                                                       // Dim Layer_Domain_Thickness As Double
                                                                                       // Dim Old_Water_Content_Layer As Double
                                                                                       // Dim Chemical_Mass_In_Layer As Double
                                                                                       // Dim Chem_Mass_Fraction_In_Solution As Double
                                                                                       // Dim Chemical_Leaching As Double
                                                                                       // Dim Bulk_Density As Double
                                                                                       // Dim Step_Final_Chemical_Mass As Double
                                                                                       // Dim Step_Chemical_Mass_Inflow As Double
                                                                                       // Dim Step_Chemical_Mass_Leaching As Double
   /*nu is now a member static const float64 nu = 0.6;   */                            // Const nu = 0.6
   /*Water_Density is a common constant   */                                           // Water_Density = 1000 'kg/m3
                                                                                       // 'Initiate chemical mass per node for the current chemical species
   float64 initial_chemical_mass = mass->sum_profile();                                // Dim Step_Initial_Chemical_Mass As Double
                                                                                       // Step_Initial_Chemical_Mass = 0
                                                                                       // For Layer = 1 To Number_Of_Soil_Layers
                                                                                       //     If NO3 Then Layer_Chemical_Mass(Layer) = Layer_Nitrate_Mass(Layer)
                                                                                       //     If NH4 Then Layer_Chemical_Mass(Layer) = Layer_Ammonium_Mass(Layer)
                                                                                       //     If Phosp Then Layer_Chemical_Mass(Layer) = Layer_Phosphorus_Mass(Layer)
                                                                                       //     If Salt Then Layer_Chemical_Mass(Layer) = Layer_Salt_Mass(Layer)
                                                                                       //     Step_Initial_Chemical_Mass = Step_Initial_Chemical_Mass + Layer_Chemical_Mass(Layer)
                                                                                       // Next Layer
   flow[0] = water_entering;                                                           // Flow(0) = Soil.WaterFlow(0) 'Flow is in to m/h (m3H2O/m2area/h)
   // Chemical concentration in irrigation water (kg chem/m3 water)
   // (In the V.B. code this is pass in the parameter Fertigation.)
   float64 actual_surface_infiltrated_M  //  kg/m2
      = relinquish_surface_mass_pending_infiltration_M(at_time,duration);
   float64 surface_water_entering_concentration
      = (water_entering > 0.0)
      ? actual_surface_infiltrated_M / water_entering
      : 0.0;
               //C++ inf   Win = Water_Flux_In / Number_Of_Pulses
   float64 conc_in = surface_water_entering_concentration;
   layer_concentration[0] = conc_in;                                                   // Layer_Concentration(0) = Fertigation  'kg S/m3 H2O
   soil_layer_array64(new_water_depth);clear_layer_array64(new_water_depth);           // Dim New_Water_Depth(mmax) As Double
   soil_layer_array64(old_water_depth);clear_layer_array64(old_water_depth);           // Dim Old_Water_Depth(mmax) As Double
   for (nat8 layer = 1; layer <= num_layers_eff; layer++)                             //For Layer = 1 To Number_Of_Soil_Layers
   {
      float64 thickness_layer  = soil_layers.get_thickness_m(layer);                   //    Layer_Thickness = Soil.LayerThickness(Layer)
      float64 layer_domain_thickness = thickness_layer;                                //    Layer_Domain_Thickness = Layer_Thickness
      // This next two lines yield units of meter (m3 water/m2 soil)
      new_water_depth[layer]                                                           //    New_Water_Depth(Layer) = Soil.NewWaterContent(Layer) * Layer_Domain_Thickness
         = new_liquid_water_content[layer] * layer_domain_thickness;
      old_water_depth[layer]                                                           //    Old_Water_Depth(Layer) = Soil.OldWaterContent(Layer) * Layer_Domain_Thickness
         = old_liquid_water_content[layer] * layer_domain_thickness;
      //  water content for the node domain at the beginning of the current time step, before FD solution for the current time step
      float64 old_water_content_layer = old_liquid_water_content[layer];               //    Old_Water_Content_Layer = Soil.OldWaterContent(Layer)
      float64 chemical_mass_in_layer = mass->get_layer(layer);                         //    Chemical_Mass_In_Layer = Layer_Chemical_Mass(Layer)
      // Added adjustment for bypass. Bypassed chemical mass will stay in the layer (not available for transport)
      float64 bypass_coef      = soil_hydraulic_properties.get_bypass_coef(layer);
      bypass_chemical_mass[layer]                                                      // as of 081001 not in V.B. Code
         = chemical_mass_in_layer * bypass_coef;                                       // as of 081001 not in V.B. Code
      float64 chemical_mass_available_for_transport                                    // as of 081001 not in V.B. Code
         =  chemical_mass_in_layer -  bypass_chemical_mass[layer];

// The following line is here only so we can see the amount of element N when debugging
float64 chemical_mass_in_layer_E =  chemical_mass_available_for_transport *  chem_to_element_factor;
//cout << chemical_mass_in_layer_E;

      if (chemical_mass_available_for_transport > 0)                                                  //    If Chemical_Mass_In_Layer > 0 Then
      {
          bool is_NH4 = dynamic_cast<NH4_Profile *>(this) != 0;
         if (is_NH4 /*NYI || is_phosphorus Eventually we will have phosphorus*/)       //        If NH4 Or Phosp Then      //080114
         {
            float64 bulk_density =soil_structure.get_bulk_density_g_cm3(layer);        //            Bulk_Density = Soil.bdValue(Layer)
            // Layer concentration in kg Chem/m3 water
            float64 chem_mass_fraction_in_solution = 0; //  kg Chem / m3 water  // <-- returned by calc_Langmuir_solute_equilibrium_concentration
            layer_concentration[layer]                                                 //          Layer_Concentration(Layer)
               =  calc_Langmuir_solute_equilibrium_concentration                       //             =  LangmuirSoluteEquilibriumConcentration
                  (chemical_mass_available_for_transport                               //                (Chemical_Mass_In_Layer                //081001
                  ,bulk_density                                                        //                ,Bulk_Density
                  ,layer_domain_thickness                                              //                ,Layer_Domain_Thickness
                  ,old_water_content_layer                                             //                ,Old_Water_Content_Layer
                  ,chem_mass_fraction_in_solution);                                    //                ,Chem_Mass_Fraction_In_Solution)
            sorbed_chemical_mass[layer] =chemical_mass_available_for_transport         //            Sorbed_Chemical_Mass(Layer) = Chemical_Mass_In_Layer * (1 - Chem_Mass_Fraction_In_Solution)   //081001
                          *(1.0 - chem_mass_fraction_in_solution);
         }
//  I dont know why this has now been disabled in the V.B. version
         else                                                                        //        Else
         {
            layer_concentration[layer] = chemical_mass_available_for_transport         //            Layer_Concentration(Layer) = Chemical_Mass_In_Layer / (Layer_Domain_Thickness * Old_Water_Content_Layer)  //081001
                  / (layer_domain_thickness * old_water_content_layer);
            sorbed_chemical_mass[layer] = 0.0;                                         //            Sorbed_Chemical_Mass(Layer) = 0         //080814
         }                                                                             //        End If

      } else // (This else is not really needed because we initialize to zero          //    Else
      {  layer_concentration[layer] = 0.0;                                             //        Layer_Concentration(Layer) = 0
         sorbed_chemical_mass[layer] = 0.0;                                            //        Sorbed_Chemical_Mass(Layer) = 0
      }                                                                                //    End If
      /* In the C++ code, the flow array is passed  */                                 //    'Flow is in m/h (m3H2O/m2area/h)
      /* whereas in the V.B. code it is obtained from soil*/                           //    Flow(Layer) = Soil.WaterFlow(Layer)
   }                                                                                   //Next Layer
   // Compute coefficients to build the tridiagonal matrix.
   soil_layer_array64(a_term);   clear_layer_array64(a_term);                          // Dim A_Term(mmax) As Double
   soil_layer_array64(b_term);   clear_layer_array64(b_term);                          // Dim B_Term(mmax) As Double
   soil_layer_array64(c_term);   clear_layer_array64(c_term);                          // Dim C_Term(mmax) As Double
   soil_layer_array64(d_term);   clear_layer_array64(d_term);                          // Dim D_Term(mmax) As Double



   for (nat8 layer = 1; layer <= num_layers_eff; layer++)                              //For Layer = 1 To Number_Of_Soil_Layers
   { // Unlike the F.D. flow is always downward so we have only one case


//std:: cout << "l:" << (int)layer << " flow-1:" <<  flow[layer-1] << " nu:"<< nu << std::endl;;                                             //        A_Term(Layer) = Flow(Layer - 1) * nu


      a_term[layer] = flow[layer-1]  * nu;                                             //        A_Term(Layer) = Flow(Layer - 1) * nu
      b_term[layer] = - new_water_depth[layer] - flow[layer]  * nu;                    //        B_Term(Layer) = -New_Water_Depth(Layer) - Flow(Layer) * nu
      c_term[layer] = 0.0;                                                             //        C_Term(Layer) = 0#
      float64 one_minus_nu = (1.0-nu);                                           //080606
      float64 nu_term = layer == 1 ? 1.0 : one_minus_nu;                               //        If Layer = 1 Then
      d_term[layer] = - old_water_depth[layer]       * layer_concentration[layer]      //            D_Term(Layer) = -Old_Water_Depth(Layer) * Layer_Concentration(Layer) _
                      + flow[layer]   * one_minus_nu  * layer_concentration[layer]     //                        + Flow(Layer) * (1# - nu) * Layer_Concentration(Layer) _
                      - flow[layer-1] * nu_term       * layer_concentration[layer-1];  //                        - Flow(Layer - 1) * Layer_Concentration(Layer - 1)
                                                                                       //            Else
                                                                                       //            D_Term(Layer) = -Old_Water_Depth(Layer) * Layer_Concentration(Layer) _
                                                                                       //                       + Flow(Layer) * (1# - nu) * Layer_Concentration(Layer) _
                                                                                       //                       - Flow(Layer - 1) * (1# - nu) * Layer_Concentration(Layer - 1)
                                                                                       //        End If

      if (d_term[layer]  > 0)                                                          //        If D_Term(Layer) > 0 Then
      {
if (flow[layer] == 0.0)
std::cerr << "flow 0" << std::endl;

         layer_concentration[layer] -=  d_term[layer] / (flow[layer] * one_minus_nu);  //            Layer_Concentration(Layer) = Layer_Concentration(Layer) - D_Term(Layer) / (Flow(Layer) * (1# - nu))
         d_term[layer] = 0.0;                                                          //            D_Term(Layer) = 0
      }                                                                                //        End If
   }                                                                                   //Next Layer



   soil_layer_array64(new_chemical_mass); clear_layer_array64(new_chemical_mass);   //080606
   resolution_of_Thomas_agorithm
      (num_layers_eff
      ,a_term    // layer or nodal array
      ,b_term    // layer or nodal array
      ,c_term    // layer or nodal array
      ,d_term    // layer or nodal array
      ,new_water_depth
      ,layer_concentration
      ,sorbed_chemical_mass                                                         //080606
      ,new_chemical_mass);                                                          //080606

// debugging only 150924
//soil_layer_array64(new_N_mass); clear_layer_array64(new_N_mass);
//float64 sum_N_mass = 0.0;
//nat32 hour = at_time/3600;
//std::cout << std::endl << hour << '(' << (hour+1) << ')' << std::endl;


   for (nat8 layer = 1; layer <= num_layers_eff; layer++)                             // as of 081001 not in V.B. Code
   {
      new_chemical_mass[layer] += bypass_chemical_mass[layer];                         // as of 081001 not in V.B. Code
// debugging only 150924
//new_N_mass[layer] = element_to_chem_factor* new_chemical_mass[layer];
//sum_N_mass += new_N_mass[layer];
//std::cout << new_N_mass[layer] << std::endl;
   }
//debug
//Nconc_dump << layer_concentration[ num_layers_eff] << "\t";
//bool is_NH4 = dynamic_cast<NH4_Profile *>(this) != 0;

//std::cout << "prof:" << sum_N_mass << std::endl;


   // Update and save chemical mass per node and chemical species for next hour
   float64 step_final_chemical_mass                                                    //Step_Final_Chemical_Mass = 0
      = mass->set_layers(new_chemical_mass ); // set_layers replaces the for loop   //080609
 /*for (nat8 layer = 1; layer <= num_layers_eff; layer++)   */                         //For Layer = 1 To Number_Of_Soil_Layers  //080115
 /*{                                                        */                         //    If NO3 Then Layer_Nitrate_Mass(Layer) = Layer_Chemical_Mass(Layer)
 /*                                                         */                         //    If NH4 Then Layer_Ammonium_Mass(Layer) = Layer_Chemical_Mass(Layer)
 /*                                                         */                         //    If Phosp Then Layer_Phosphorus_Mass(Layer) = Layer_Chemical_Mass(Layer)
 /*                                                         */                         //    If Salt Then Layer_Salt_Mass(Layer) = Layer_Chemical_Mass(Layer)
 /*   step_final_chemical_mass += new_chemical_mass[layer]; */                         //    Step_Final_Chemical_Mass = Step_Final_Chemical_Mass + Layer_Chemical_Mass(Layer)
 /*   mass->set_layer(layer,new_chemical_mass[layer]);      */                         //    Soil.LayerChemicalMass(Layer) = Layer_Chemical_Mass(Layer)
 /*} // for layer                                           */                         //Next Layer
   float64 chemical_mass_inflow_now = flow[0] * layer_concentration[0];                //Step_Chemical_Mass_Inflow = Flow(0) * Layer_Concentration(0) //080114
   float64 chemical_mass_leached_now                                                   //Step_Chemical_Mass_Leaching = Step_Initial_Chemical_Mass - Step_Final_Chemical_Mass + Step_Chemical_Mass_Inflow //080114
      = initial_chemical_mass - step_final_chemical_mass + chemical_mass_inflow_now;      //080114
   inc_balance_leached_M(chemical_mass_leached_now); //kg/m2/h                   //080115
   // WARNING Used to be able to report leaching at layer,
   // but we no longer have chem flows by layer.
   inc_reported_leached_M(chemical_mass_leached_now);                            //080115
   // Sum_Solute_Inflow and Sum_Solute_Leaching  not used in C++ version               //Sum_Solute_Inflow = Sum_Solute_Inflow + Step_Chemical_Mass_Inflow
                                                                                       //Sum_Solute_Leaching = Sum_Solute_Leaching + Step_Chemical_Mass_Leaching 'kg/m2/h
}
//_2008-06-05___________________________________________________________________
void Chemical_profile::transport_unidirectional_original
(nat8 num_layers_eff
,soil_layer_array64(flow)  // m3 water/m2 soil (m water depth)   flow out of the layer //070117
,soil_layer_array64(old_liquid_water_content)
,soil_layer_array64(new_liquid_water_content)
,float64 water_entering
,Seconds                at_time                                                  //071015
,Seconds                duration // seconds of duration                          //071015
,bool override_drainage_depth
,nat8 drainage_sublayer)
{ // This should work with any timestep - RLN

   soil_layer_array64(new_concentration); clear_layer_array64(new_concentration); // concentration of chemical in water kg/m3 //070924
   soil_layer_array64(new_amount);        clear_layer_array64(new_amount);       //070924
      mass->get_layers(new_amount);                                              //080117
//inf   Drainage = 0 'Initialize drainage flux

//C++ inf     'Calculates initial soil water profile (kg/m2 or mm) and total chemical mass in the soil profile (kg/m2)

//C++ handled    Initial_Profile_Chemical_Mass = 0
//C++ inf    Initial_Soil_Water_Profile = 0
//C++ inf    For L = 1 To Number_Of_Layers
//C++ inf    Initial_Soil_Water_Profile = Initial_Soil_Water_Profile + WC(L) * DZ(L) * Water_Density
//C++ handled    Initial_Profile_Chemical_Mass = Initial_Profile_Chemical_Mass + Chem_Mass(L)
//C++ inf    Next L

   // Equilibrate soil solution
   float64 K = get_constantC();
   float64 Q = get_constantQ();
   float64 unused_chem_mass_fraction_in_solution = 0;
   bool use_langmuir = (K > 0) && (Q > 0);
   for (nat8 layer = 1; layer < num_layers_eff; layer++)
   {
      float64 chemical_mass   = mass->get_layer(layer);
      float64 thickness_layer  = soil_layers.get_thickness_m(layer);
      new_concentration[layer] = use_langmuir
         ? calc_Langmuir_solute_equilibrium_concentration
            (chemical_mass
            ,soil_structure.get_bulk_density_Mg_m3(layer)            // 071001 Warning Claudio check units,
            ,thickness_layer
            ,old_liquid_water_content[layer]                         // 071001 Warning Claudio not sure if this should be new or old WC
            ,unused_chem_mass_fraction_in_solution)
         : chemical_mass / (thickness_layer * old_liquid_water_content[layer] * water_density);
   }

/* C++ inf
    'Calculate pore volume equivalent of each water pulse
    If Number_Of_Pulses = 0 Then
        Water_Depth_Equivalent_Of_One_Pore_Volume = water_density * DZ(1) * FC(1)
        Number_Of_Pulses = 1 + Int(Water_Flux_In / (0.2 * Water_Depth_Equivalent_Of_One_Pore_Volume))
    End If
*/
//C++ inf    For i = 1 To Number_Of_Pulses

   flow[0] = water_entering;                                                     //071001
   float64 actual_surface_infiltrated_M  //  kg/m2                               //071015
      = relinquish_surface_mass_pending_infiltration_M(at_time,duration);        //071015
   float64 surface_water_entering_concentration                                  //071015
      = actual_surface_infiltrated_M / water_entering;                           //071015

//C++ inf         ___________     Win = Water_Flux_In / Number_Of_Pulses
   float64 conc_in = surface_water_entering_concentration;  // Chemical concentration in irrigation water (kg chem/m3 water)
/*for debugging
#ifdef HAVE_ELEMENTAL_FORM
float64 DEBUG_conc_in_E=  conc_in *  chem_to_element_factor; // only for debug
float64 DEBUG_mass_out_E = 0;
float64 DEBUG_conc_out_E = 0;
#endif
*/
   float64 mass_out = 0;
   float64 conc_out = 0;
   for (nat8 layer = 1; layer <= num_layers_eff; layer++)
   {  float64 thickness_layer  = soil_layers.get_thickness_m(layer);
      float64 bypass_coef      = soil_hydraulic_properties.get_bypass_coef(layer);  //980102
      float64 Win  = flow[layer-1]; // m3 water/m2 soil (m water depth)
      float64 Wout = flow[layer];   // m3 water/m2 soil (m water depth)
      float64 mass_in  = Win * conc_in;        // kg/m2                          //071001
/*debug
#ifdef HAVE_ELEMENTAL_FORM
float64 DEBUG_mass_in_E  = mass_in * chem_to_element_factor;
#endif
*/
      conc_out = 0;
//C++ inf         Water_Depth_To_Reach_Field_Capacity = (FC(layer) - WC(layer)) * DZ(layer) * water_density
//C++ inf           'Determine water and chemical transport
//C++ inf         If Win > Water_Depth_To_Reach_Field_Capacity Then
      if (Wout > 0.0)
      {
//C++ inf               Wout = Win - Water_Depth_To_Reach_Field_Capacity

            conc_out =
               (  (1.0 - bypass_coef) * thickness_layer
                  /** water_density*/ * old_liquid_water_content[layer]
                  * new_concentration[layer]
                 + mass_in)
               / (Win  + (1.0 - bypass_coef) * thickness_layer
                        /** water_density*/ * old_liquid_water_content[layer]);

          // Note that this is different from the V.B. version because
          // the V.B. version concentrations are kg/kg not kg/m3.

//Conc_Out = ((1 - Bypass_Fraction) * DZ(j) * WD * WC(j) * C(j) + Win * Conc_In) / (Win + (1 - Bypass_Fraction) * DZ(j) * WD * WC(j))
/* debug
#ifdef HAVE_ELEMENTAL_FORM
DEBUG_conc_out_E  = conc_out * chem_to_element_factor;
#endif
*/
//C++ inf               new_liquid_water_content(layer) = FC(layer)
      // else default  conc_out = 0;
//C++ inf               Wout = 0
//C++ default___________             conc_out = 0;
//C++ inf               new_liquid_water_content(layer) = old_liquid_water_content(layer) + Win / (water_density * DZ(layer))
      } // end if Wout
      mass_out = Wout * conc_out;                                                //071001
      float64 mass_change = mass_in - mass_out;
      float64 mass_layer  = mass->get_layer(layer);                              //080117
/* debug
#ifdef HAVE_ELEMENTAL_FORM
DEBUG_mass_out_E  = mass_out * chem_to_element_factor;
float64 DEBUG_mass_change_E =  mass_change * chem_to_element_factor;
float64 DEBUG_mass_layer_E = mass_layer * chem_to_element_factor;
#endif
*/
      if ((mass_change < 0) && (fabs(mass_change) > mass_layer /*080117 amount_M[layer]*/) )
      {  // In this case we moved all the chemical out of the layer
         mass_change = -mass_layer /*080117 amount_M[layer]*/;
         mass_out = mass_in - mass_change;                                       //071001
         conc_out = mass_out / Wout;
/*debug
#ifdef HAVE_ELEMENTAL_FORM
DEBUG_mass_out_E  = mass_out * chem_to_element_factor;
DEBUG_conc_out_E =  conc_out * chem_to_element_factor;
float64 DEBUG_mass_change_E  = mass_change * chem_to_element_factor;
#endif
*/
         new_amount        [layer] = 0.0;
         new_concentration [layer] = 0.0;
      } else
      {  new_amount[layer] = mass_layer + mass_change;
         new_concentration[layer] = (new_liquid_water_content[layer] > 0.0)      //080601
             ? new_amount[layer] / (thickness_layer * new_liquid_water_content[layer] * water_density)
             : 0;                                                                //080601
      }
//C++ inf         Win = Wout
      conc_in = conc_out;
/*debugging
#ifdef HAVE_ELEMENTAL_FORM
DEBUG_conc_in_E =  conc_in * chem_to_element_factor;
#endif
*/
      if (override_drainage_depth)                                               //981230
            inc_reported_leached_M(mass_out);                                    //990317
   } // for layer
   for (nat8 layer = 1; layer <= num_layers_eff; layer++)                        //080115
   {                                                                             //080115
      mass->set_layer(layer,new_amount[layer]);                                  //080117
   } // for layer                                                               //080115
   mass->commit_diffs();                                                         //120731

//C++ inf      Drainage = Drainage + Wout     'in mm/day = kg/m2/day
   float64 leaching = mass_out;  /*leaching +Wout * Conc_Out */

#ifdef HAVE_ELEMENTAL_FORM
float64 leaching_E =  leaching * chem_to_element_factor;
#endif

//C++ handled     Next i 'Next pulse
//C++ handled     For i = 1 To Number_Of_Layers
//C++ handled     'Equilibrate soil solution
//C++ handled     If (K > 0) And (Q > 0) Then
//C++ handled        For L = 1 To layer - 1
//C++ handled          new_concentration(L) = EquilibriumConcentration(Chem_Mass(L), new_liquid_water_content(L), DZ(L), BD(L), K, Q)
//C++ handled        Next L
//C++ handled          Else
//C++ handled          For L = 1 To Number_Of_Layers
//C++ handled          new_concentration(L) = Chem_Mass(L) / (DZ(L) * new_liquid_water_content(L) * water_density)
//C++ handled          Next L
//C++ handled     End If

//C++ inf  Next i 'Next layer

//C++ handled 'Calculates Final total chemical mass in the soil profile (kg/m2)

//C++ handled   Final_Profile_Chemical_Mass = 0
//C++ handled   For L = 1 To Number_Of_Layers
//C++ handled     Final_Profile_Chemical_Mass = Final_Profile_Chemical_Mass + Chem_Mass(L)
//C++ handled   Next L

//C++ handled    Chemical_Balance = Chemical_Balance + (Initial_Profile_Chemical_Mass + Water_Flux_In * Chem_Conc_Irrigation _
//C++ handled                    - (Final_Profile_Chemical_Mass + leaching)) * 10000 'transform kg/m2 to kg/ha

//C++ handled  'Calculates final soil water profile (kg/m2 or mm)

//C++ inf    Final_Soil_Water_Profile = 0
//C++ inf    For L = 1 To Number_Of_Layers
//C++ inf    Final_Soil_Water_Profile = Final_Soil_Water_Profile + new_liquid_water_content(L) * DZ(L) * water_density
//C++ inf    Next L

//    Water_Balance = Water_Balance + (Initial_Soil_Water_Profile + Water_Flux_In - (Final_Soil_Water_Profile + Drainage))

   inc_balance_leached_M(leaching);
   inc_reported_leached_M(leaching);                                             //080115
   //For cascade method, nothing is done with water_table_conc.
}   // end of local function transport
//______________________________________________________________________________
// Thomas algorithm using a system of equations
#ifdef FINITE_DIFF
void Chemical_profile::transport_bidirectional_by_node
(nat8 num_nodes_eff
,nat8 number_of_real_plus_extended_nodes                                        //080219
,bool water_table_condition                                                      //080206
,soil_layer_array64(flow) // m3 water/m2 soil (m) in the day  flow out of the layer  from one node to the next (through the layer) Positive is downward.  (RLN not sure if nodal or layer)   //070117
,soil_node_array64(old_water_depth_nodal)  // Claudio what were the units of this?
,soil_node_array64(new_water_depth_nodal)
,float64 water_entering
,Seconds at_time                                                                 //071015
,Seconds duration // seconds of duration                                         //071015
,bool    override_leaching_depth                                                 //981230
,nat8   leaching_sublayer // for recording at an observation depth              //981230
)
{ // This should work with any timestep - RLN
  // Used for finite difference                                                  //071001

/*
if (chemical_type == 1)
{
std::cout << "Warning NO3 transport disabled for debug" << std::endl;
return;
}
*/

   float64 init_mass = 0.0;
   bool is_NH4 = dynamic_cast<NH4_Profile *>(this) != 0;
   if (!is_NH4)
   {  init_mass = mass->sum_profile();
      // cout << init_mass;
   }
   // Convert layer chemical mass system to nodal system.
   nat8 soil_num_layers   = soil_layers.get_number_layers();                    //071217
   Chemical_mass_profile_node_based &mass_node = (Chemical_mass_profile_node_based &)*mass;  //071217
   static const float64 nu = 0.6;
   soil_node_array64(sorbed_chemical_mass); clear_node_array64(sorbed_chemical_mass);  //080114
   soil_node_array64(bypass_chemical_mass); clear_node_array64(bypass_chemical_mass);  //080114

   //We need to get a common units for water_flow because water flux
   //  units are different in finite diff and cascade:
   // flow checked with Pascal 960319
   flow[0] = water_entering;
   // RLN Warning I think at this point water_entering is the value
   // of all the water entering the soil, but at this point
   // flow has already been accounted for

   // Get salt from application waiting on the surface:
   float64 actual_surface_infiltrated_M  // kg/ha                                //071015
      = relinquish_surface_mass_pending_infiltration_M(at_time,duration);        //071015
   float64 surface_water_entering_concentration  // kg chem / m3 water  Claudio check  //071015
      = CORN::is_approximately<float64>(water_entering,0.0,0.000001) ? 0.0
         : actual_surface_infiltrated_M / water_entering;                        //071015
///*071220_*/     // need to set concentration_0
   soil_layer_array64(node_concentration); clear_layer_array64(node_concentration);  // kg chem/m^3 water   //070924
   node_concentration[0] = surface_water_entering_concentration;                 //071220
#ifdef WATERTABLE
   if (water_table_condition)                                        // If Not FDWaterTransport.FreeDrainage Then //080206
   {
#ifdef NYI
      for (int8 node = num_nodes_eff + 1; node <= MAX_soil_layers; node++)
         node_concentration[node]                         //     Node_Concentration(Number_Of_Nodes + 1) = Water_Table_Concentration
          = water_table_concentration;                               // End If
#endif
       node_concentration[num_nodes_eff + 1]                         //     Node_Concentration(Number_Of_Nodes + 1) = Water_Table_Concentration //080206
          = water_table_concentration;                               // End If   //080206
   }
#endif   
   float64 initial_chemical_mass = 0.0;                                          //080114
   float64 sorbed_chemical_mass_sum = 0.0;                                       //080114

#ifdef _DEBUG
soil_node_array64(DEBUG_chemical_mass_node_E); clear_node_array64(DEBUG_chemical_mass_node_E); // only for debugging
soil_node_array64(DEBUG_chemical_conc_E); clear_node_array64(DEBUG_chemical_conc_E);
#endif
   soil_node_array64(node_chemical_mass); clear_node_array64(node_chemical_mass);                     //080219
   soil_node_array64(node_bypassed_chemical_mass); clear_node_array64(node_bypassed_chemical_mass);   //081001
   for (nat8 node =  1 ; node <= number_of_real_plus_extended_nodes; node ++)                        //080219
   {  // RLN The following is consistent with the V.B. but I am not sure the V.B. code is right.      //080219
      node_chemical_mass[node] = mass_node.get_node(node,number_of_real_plus_extended_nodes);         //080220
      initial_chemical_mass +=                                                                        //080114
         node_chemical_mass[node];
#ifdef _DEBUG
DEBUG_chemical_mass_node_E[node] = node_chemical_mass[node]* chem_to_element_factor; // only for debugging
DEBUG_chemical_conc_E[node] =  node_concentration[node] *  chem_to_element_factor;
#endif
   }
   for (nat8 node =  1 ; node <= num_nodes_eff ; node ++)                       //071220
   {  nat8 layer = node;                                                        //071220
      float64      thickness_layer  = soil_layers.get_thickness_m(layer); // should be 0 for    num_nodes_eff
      float64 thickness_prev_layer =  soil_layers.get_thickness_m(layer-1);      //071220
      float64 node_domain_thickness = (thickness_layer  + thickness_prev_layer) / 2.0; //071220
      // water content for the node domain at the beginning of the current time step, before FD solution for the current time step
      float64 old_water_content_node = old_water_depth_nodal[node] / node_domain_thickness;  //080114
      float64 chemical_mass_in_node   // kg chem/ m^2 soil                       //080114
         =  node_chemical_mass[node];                                            //080219
      // Added adjustment for bypass. Bypassed chemical mass will stay in the layer (not available for transport) 081001
      float64 bypass_coef      = soil_hydraulic_properties.get_bypass_coef(layer);   // RLN: Warning I am presuming we can simply use the layer bypass coefficient for the node
      bypass_chemical_mass[node]                                                 //081001 120516 now in V.B. Code
         = node_chemical_mass[node] * bypass_coef;                               //081001 120516 now in V.B. Code
      float64 chemical_mass_in_node_available_for_transport                      //081001 120516 now in V.B. Code
         =  chemical_mass_in_node -  bypass_chemical_mass[node];                 //081001
      #ifdef _DEBUG
      DEBUG_chemical_mass_node_E[node] = chemical_mass_in_node * chem_to_element_factor;
      #endif

      node_concentration[node]   = 0.0;                                          //080114
      sorbed_chemical_mass[node] = 0.0;                                          //080114
      if (chemical_mass_in_node_available_for_transport > 0)                     //080114
      {  bool is_NH4 = dynamic_cast<NH4_Profile *>(this) != 0;
         if (is_NH4 /*NYI || is_phosphorus*/ ) // Eventually we will have phosphorus
         {
            float64 bulk_density =
            (node == 1)
            ?  soil_structure.get_bulk_density_g_cm3(1)
            :  (node == num_nodes_eff)
               ? soil_structure.get_bulk_density_g_cm3(layer-1)
               :  (soil_structure.get_bulk_density_g_cm3(layer - 1) * thickness_prev_layer
                   + soil_structure.get_bulk_density_g_cm3(layer) * thickness_layer)
                  / (thickness_layer + thickness_prev_layer);
            // Node concentration in kg Chem/m3 water
            float64 chem_mass_fraction_in_solution = 0; //  kg Chem / m3 water
            node_concentration[node]
               = calc_Langmuir_solute_equilibrium_concentration
                  (chemical_mass_in_node_available_for_transport                 //081001
                  ,bulk_density
                  ,node_domain_thickness
                  ,old_water_content_node
                  ,chem_mass_fraction_in_solution);  // <-- returned by calc_Langmuir_solute_equilibrium_concentration
            sorbed_chemical_mass[node]                                           //081001
               = chemical_mass_in_node_available_for_transport
                     * (1.0 - chem_mass_fraction_in_solution);
            sorbed_chemical_mass_sum += sorbed_chemical_mass[node];
            // sorbed_chemical_mass is chemical mass not available for movement
         } else
         {  // Not NH4
            node_concentration[node] = chemical_mass_in_node_available_for_transport // 081001 chemical_mass_in_node
                  / (node_domain_thickness * old_water_content_node);
            sorbed_chemical_mass[node] = 0.0;
         }
      }
#ifdef _DEBUG
DEBUG_chemical_conc_E[node] =  node_concentration[node] *  chem_to_element_factor; // for debugging only
#endif
   }
   // Compute coefficients to build the tridiagonal matrix.
   soil_node_array64(a_term);   clear_node_array64(a_term);                      //070924
   soil_node_array64(b_term);   clear_node_array64(b_term);                      //070924
   soil_node_array64(c_term);   clear_node_array64(c_term);                      //070924
   soil_node_array64(d_term);   clear_node_array64(d_term);                      //070924

soil_node_array64(DEBUG_d_term_E);   clear_node_array64(DEBUG_d_term_E); // for debugging only

   for (nat8 node =  1 ; node <= num_nodes_eff; node ++)
   {  // System of equations   4 euqations 2 unknowns with a fixed concentration above and below as boundary conditions
     if (flow[node] > 0)  //flow from current layer is downward
     {  if (flow[node-1] > 0 )  // Case 1: flow from current layer is downward and flow from upper layer is downward or zero  //080206
        {  a_term[node] = flow[node-1]  * nu;
           b_term[node] = - new_water_depth_nodal[node] - flow[node]  * nu;
           c_term[node] = 0.0;
           float64 nu_term = node == 1 ? 1.0 : (1.0-nu);                         //080206
           d_term[node] =  - old_water_depth_nodal[node] * node_concentration[node]
                           + flow[node]   * (1.0 - nu) * node_concentration[node]
                           - flow[node-1] * nu_term    * node_concentration[node-1];   //080206
        } else  // Case 2: if flow[node-1] <= 0 THEN flow from current layer is downward and flow from upper layer is upward
        {  a_term[node] = 0.0;
           b_term[node] = - new_water_depth_nodal[node] + nu * (flow[node-1] - flow[node]);
           c_term[node] = 0.0;
           d_term[node] =  - old_water_depth_nodal[node] * node_concentration[node]
                           + flow[node]   * (1.0 - nu) * node_concentration[node]
                           - flow[node-1] * (1.0 - nu) * node_concentration[node] ;
        }
        if (d_term[node] > 0) // avoid negative chemical mass                    // If D_Term(Node) > 0 Then        //120517
            node_concentration[node] -= d_term[node] / flow[node] * (1.0 - nu);  //      Node_Concentration(Node) = Node_Concentration(Node) - D_Term(Node) / (Flow(Node) * (1# - nu))
                                                                                 //       D_Term(Node) = 0
                                                                                 // End If
     }   // end  of downward flow
     else  // if flow[node] < 0 THEN flow from current layer is upward
     {  if (flow[node-1] > 0) // Case 3: flow from current layer is upward and flow from upper layer is downward or zero   //080206
        {  a_term[node] = flow[node-1] * nu;
           b_term[node] = - new_water_depth_nodal[node];
           c_term[node] = - flow[node] * nu;
           float64 nu_term = node == 1 ? 1.0 : (1.0-nu);                         //080206
           d_term[node] =  - old_water_depth_nodal[node] * node_concentration[node]
                           + flow[node]   * (1.0 - nu) * node_concentration[node+1]
                           - flow[node-1] * nu_term    * node_concentration[node-1] ;  //080206
        } else //Case 4: if flow[i-1] <= 0 THEN  flow from current layer is upward and flow from upper layer is upward
        {  a_term[node] = 0;
           b_term[node] = - new_water_depth_nodal[node] + flow[node-1] * nu;
           c_term[node] = - flow[node] * nu;
           d_term[node] =  - old_water_depth_nodal[node] * node_concentration[node]
                           + flow[node]   * (1.0 - nu) * node_concentration[node+1]
                           - flow[node-1] * (1.0 - nu) * node_concentration[node]  ;
        }

         if (d_term[node] > 0) // avoid negative chemical mass                   // If D_Term(Node) > 0 Then //120517
            node_concentration[node+1] -= d_term[node] / flow[node] * (1.0 - nu); //           Node_Concentration(Node + 1) = Node_Concentration(Node + 1) - D_Term(Node) / (Flow(Node) * (1# - nu))
                                                                                 //            D_Term(Node) = 0
                                                                                 //        End If
     }  /*end flow upward*/

DEBUG_d_term_E[node] = d_term[node] *  chem_to_element_factor;
                 if (CORN::is_approximately<float64>(a_term[node],0.0,0.0000000000001)) a_term[node] = 0.0;
                 if (CORN::is_approximately<float64>(b_term[node],0.0,0.0000000000001)) b_term[node] = 0.0;
                 if (CORN::is_approximately<float64>(c_term[node],0.0,0.0000000000001)) c_term[node] = 0.0;
                 if (CORN::is_approximately<float64>(d_term[node],0.0,0.0000000000001)) d_term[node] = 0.0;


  } /*end of for i=1 to nl_effective*/
   soil_node_array64(new_node_chemical_mass); clear_node_array64(new_node_chemical_mass); //080114
   resolution_of_Thomas_agorithm                                                          //080606
      (num_nodes_eff                                                                      //080606
      ,a_term
      ,b_term
      ,c_term
      ,d_term
      ,new_water_depth_nodal
      ,node_concentration
      ,sorbed_chemical_mass // layer or nodal array                              //080606
      ,new_node_chemical_mass                                                    //081001
      );                                                                         //080606
   for (nat8 node =  1 ; node <= num_nodes_eff ; node ++)                        //081001
   {
      new_node_chemical_mass[node] += bypass_chemical_mass[node];                         // as of 081001 not in V.B. Code

      if (new_node_chemical_mass[node] < 0.0)
         std::cout << "Reached" << std::endl;
   }
#ifdef WATERTABLE
   if (water_table_curve)
      for (nat8 node = num_nodes_eff + 1; node <= number_of_real_plus_extended_nodes ; node++)           //110330
      {  /* make sure with have chemical mass from water table */                    //110330
         nat8 layer = node;
         float64 thickness_layer  = soil_layers.get_thickness_m(layer);
         float64 thickness_prev_layer =  soil_layers.get_thickness_m(layer-1);
         float64 node_domain_thickness = (thickness_layer  + thickness_prev_layer) / 2.0;
         float64 saturation_WC = soil_hydraulic_properties.get_saturation_water_content_volumetric(node,ICE_WATER_CONTENT_RELEVENCE_UNKNOWN_140822);
         float64 water_table_conc = water_table_curve->get_for_today();  // kg/m
         float64 chem_mass = water_table_conc * (node_domain_thickness * saturation_WC); //110330
         	//       kg/m = kg/m * ( m * m/m)
         new_node_chemical_mass[node]  = chem_mass;  // kg/m
      } // for each node
#endif
   float64 final_chemical_mass_eff = mass_node.set_nodes                         //080220
      (new_node_chemical_mass                                                    //080220
      //090923 I think this line is needed instead of the next but will need to fixup balance /*090923_*/       ,num_nodes_eff
      ,number_of_real_plus_extended_nodes                                        //080220
      ,chem_to_element_factor);                                                  //080220
   float64 chemical_mass_inflow_now = flow[0] * node_concentration[0];           //080114
   float64 chemical_mass_leached_now = initial_chemical_mass - final_chemical_mass_eff + chemical_mass_inflow_now;   //080114
   //UNUSED     sum_solute_inflow += chemical_mass_inflow_now;                   //080114
   inc_balance_leached_M(chemical_mass_leached_now); //kg/m2/h                   //080115

   // WARNING Used to be able to report leaching at layer,                       //080115
   // but we no longer have chem flows by layer.                                 //080115

   inc_reported_leached_M(chemical_mass_leached_now);                            //080115

// for debugging:
float64 final_mass = mass->sum_profile() + chemical_mass_leached_now;
float64 final_mass_E =  final_mass * chem_to_element_factor;
}   // end of local function transport
#endif
//______________________________________________________________________________
void Chemical_profile::inc_balance_leached_M(float64 leached_molecular)
{  if (! CORN::is_approximately<float64>(leached_molecular,0.0,0.00000001))              //120704
   {  balance_leached_molecular +=leached_molecular;
      if (ANNL_bal_accums)       ANNL_bal_accums   ->inc_balance_leached_M(leached_molecular);
      if (GP_bal_accums_current) GP_bal_accums_current->inc_balance_leached_M(leached_molecular);
      if (CONT_bal_accums)       CONT_bal_accums  ->inc_balance_leached_M(leached_molecular);
      #if (REACCH_VERSION < 2)
      if (FALLOW_bal_accums)     FALLOW_bal_accums->inc_balance_leached_M(leached_molecular);
      #endif
   }
}
//_1999-03-17___________________________________________________________________
void Chemical_profile::inc_reported_leached_M(float64 leached_molecular)
{  if (! CORN::is_approximately<float64>(leached_molecular,0.0,0.00000001))              //120704
   {  reported_leached_molecular +=leached_molecular;
      if (ANNL_bal_accums)       ANNL_bal_accums      ->inc_reported_leached_M(leached_molecular);
      if (GP_bal_accums_current) GP_bal_accums_current->inc_reported_leached_M(leached_molecular);
      if (CONT_bal_accums)       CONT_bal_accums      ->inc_reported_leached_M(leached_molecular);
      #if ( REACCH_VERSION < 2)
      if (FALLOW_bal_accums)     FALLOW_bal_accums    ->inc_reported_leached_M(leached_molecular);
      #endif
   }
}
//_1999-03-17___________________________________________________________________
void Chemical_profile::set_reported_leached_M()
{  reported_leached_molecular       = balance_leached_molecular;
   if (ANNL_bal_accums)       ANNL_bal_accums      ->set_reported_leached_M();
   if (GP_bal_accums_current) GP_bal_accums_current->set_reported_leached_M();
   if (CONT_bal_accums)       CONT_bal_accums      ->set_reported_leached_M();
   #if (REACCH_VERSION < 2)
   if (FALLOW_bal_accums)     FALLOW_bal_accums    ->set_reported_leached_M();
   #endif
}
//_1999-03-17___________________________________________________________________
float64 Chemical_pool::water_content_correction
(float64 //sublayer_saturation_water_content // unused parameter given for virtual compatibility
,float64 //sublayer_water_content            // unused parameter given for virtual compatibility
,float64 //sublayer_reference_water_content  // unused parameter given for virtual compatibility
,float64 //sublayer_bulk_density             // unused parameter given for virtual compatibility
)
{ return 1.0; }
//______________________________________________________________________________
float64 Chemical_pool::get_current_profile_content_M()
{  float64 current_profile_content_M =
   mass->sum_profile();                                                          //080117
   return current_profile_content_M;
}
//_1998-10-06___________________________________________________________________
bool Chemical_pool::reinitialize_for_sowing_or_restart() // 960806P   (sowing or reemergence
{  // moved to GP_rprt_accums
   //GP_original_profile_content_M := current_profile_content_M;
   // Through away the fallow and start the growing season accums
   #if (REACCH_VERSION < 2)
   if (FALLOW_bal_accums) delete FALLOW_bal_accums; FALLOW_bal_accums = 0;       //990317
   #endif
   if (GP_bal_accums_current)  delete GP_bal_accums_current;                    //120503
   GP_bal_accums_current = 0;                                                    //070801
   GP_bal_accums_current= new Chemical_balance_accumulators
      (get_current_profile_content_M()
      ,name
      ,get_transformation_name()
      ,chem_to_element_factor
      ,has_uptake());
   return true;                                                                  //131217
}
//______________________________________________________________________________
bool Chemical_pool::reinitialize_at_end_season()
{
   // Throw away the growing season and start the fallow                         //041001
   #if (REACCH_VERSION < 2)
//   if (GP_bal_accums_at_end_season)     delete GP_bal_accums_at_end_season; GP_bal_accums_at_end_season=   GP_bal_accums_current;  //070801
//   GP_bal_accums_current = 0;                                                    //070801
   FALLOW_bal_accums = new Chemical_balance_accumulators                         //050114
      (get_current_profile_content_M(),name,get_transformation_name(),chem_to_element_factor,has_uptake());
   #endif
   return true;                                                                  //131217
}
//_1996-09-02___________________________________________________________________
void Chemical_pool::remove_sublayer_2(nat8 num_layers)
{
   if (num_layers >= 3)
   {  // Move any residual chemical to the next layer.
      mass->set_layer(3,mass->get_layer(2));                                     //080117
      transformed_from_M[3] += transformed_from_M[2];
      for (nat8 layer = 2; layer <=num_layers - 1 ; layer++)
      {  mass->set_layer(layer,mass->get_layer(layer+1));                        //080117
         transformed_from_M[layer] = transformed_from_M[layer+1];
      }
      mass->set_layer(num_layers,0.0);                                           //080117
      transformed_from_M[num_layers] = 0;
   } else   // In the unlikely event that we deplete all the soil, just put
   {        // the residual in the evaporative layer which we dont remove.
      mass->set_layer(1,mass->get_layer(2));                                     //080117
      transformed_from_M[1] = transformed_from_M[2];
   }
   mass->commit_diffs();                                                         //120731
}
//_1996-08-28___________________________________________________________________
float64 Chemical_pool::moisture_function
(float64 // unused water_field_porosity
,float64) //unused sublayer_bulk_density
{ return NO_MOISTURE_FUNCTION; }
//______________________________________________________________________________
float64  Chemical_pool::transformation_rate
(float64 //unused soil_temperature
,float64) //unused water_content_correct)
{ return 0.0; }
//______________________________________________________________________________
void Chemical_pool::transformation
(nat8 layer
,float64 sublayer_water_content
,float64 sublayer_saturation_water_content
,float64 sublayer_reference_water_content
,float64 sublayer_temperature
,float64 sublayer_bulk_density
,Seconds preferred_transformation_time_step_used_by_subclasses                   //060510
   // The original transformation time step is 86400 seconds (1 day)
   // When using  Organic_matter_residues_profile_V4_4,
   // the nitrification and denitrification transformation timestep is 1 hour
   // (or the timestep of the infiltration model).
,float64 &transformed_to_M)
{  float64 trans_rate =                                                          //981212
        transformation_rate
         (sublayer_temperature,
          water_content_correction
             (sublayer_saturation_water_content,
              sublayer_water_content,sublayer_reference_water_content,sublayer_bulk_density));
   float64 water_filled_porosity = sublayer_water_content / (1 - sublayer_bulk_density / 2.65); //060629
   float64 moist_funct = moisture_function                                       //060629
         (water_filled_porosity,1.0);                                            //060629
   float64 transformed_M =
      mass->get_layer(layer)                                                     //080117
      * (1- exp(- trans_rate )) *  moist_funct;
   inc_transformed_to(transformed_M);                                            //990317
   mass->dec_layer(layer,transformed_M);                                            //120731_080117
  transformed_to_M += transformed_M;   // Incremented because there may be two sources of transformation
}
//______________________________________________________________________________
void Chemical_pool::inc_transformed_to(float64 transformed_M)
{
   if (transformed_M != 0)                                                       //120704
   {
      if (ANNL_bal_accums)       ANNL_bal_accums   ->inc_transformed_to(transformed_M);
      if (GP_bal_accums_current) GP_bal_accums_current->inc_transformed_to(transformed_M);
      if (CONT_bal_accums)       CONT_bal_accums   ->inc_transformed_to(transformed_M);
      #if ( REACCH_VERSION < 2)
      if (FALLOW_bal_accums)     FALLOW_bal_accums ->inc_transformed_to(transformed_M);
      #endif
   }
}
//_1999-03-17___________________________________________________________________
void Chemical_pool::dec_residue(float64 _amount_M)
{
   if (_amount_M != 0)                                                           //120704
   {
      if (ANNL_bal_accums)       ANNL_bal_accums   ->dec_residue(_amount_M);
      if (GP_bal_accums_current) GP_bal_accums_current->dec_residue(_amount_M);
      if (CONT_bal_accums)       CONT_bal_accums   ->dec_residue(_amount_M);
      #if ( REACCH_VERSION < 2)
      if (FALLOW_bal_accums)     FALLOW_bal_accums ->dec_residue(_amount_M);
      #endif
   }
}
//_1999-03-17___________________________________________________________________
void Chemical_pool::recalibrate
( soil_layer_array64(new_amount_E_by_layer)                                      //011119
, bool for_initialization)
{  nat8 soil_num_layers = soil_layers.get_number_layers();
   soil_layer_array64(new_mass_layers); clear_layer_array64(new_mass_layers);    //080208
   for (int layer = 1; layer <= soil_num_layers; layer ++)
   {  float64 amount_E_sl = new_amount_E_by_layer[layer];                        //020305
         // Note that amount_E could either be mass or ECw depending on the context
      new_mass_layers[layer] =
         element_to_chem_factor * (per_ha_to_per_m2(amount_E_sl));               //080206
   }
   recalibrate_set_mass(new_mass_layers, for_initialization);                    //080402
}
//_2001-11-15___________________________________________________________________
void Chemical_pool::recalibrate_set_mass
(soil_layer_array64(new_mass_layers),bool for_initialization)
{  recalibration = 0.0;
   nat8 soil_num_layers = soil_layers.get_number_layers();
   for (int layer = 1; layer <= soil_num_layers; layer ++)
   {  float64 curr_mass_layer = mass->get_layer(layer);                          //080208
      float64 diff =curr_mass_layer - new_mass_layers[layer];                    //080403
      recalibration += diff;
   }
   mass->set_layers(new_mass_layers);
   if (for_initialization)
      recalibration = 0.0;                                                       //011119
      // When we are initializing the chemical profile, we just set the new values (no recalibration adjustment to the balance).
   else                                                                             //011119
   {
      if (ANNL_bal_accums)       ANNL_bal_accums      ->recalibrate(recalibration); //011115
      if (GP_bal_accums_current) GP_bal_accums_current->recalibrate(recalibration); //011115
      if (CONT_bal_accums)       CONT_bal_accums      ->recalibrate(recalibration); //011115
      #if (REACCH_VERSION < 2)
      if (FALLOW_bal_accums)     FALLOW_bal_accums    ->recalibrate(recalibration); //011115
      #endif
   }
}
//_2008-04-03___________________________________________________________________
float64 Chemical_profile::
calc_Langmuir_solute_equilibrium_concentration
(float64 chemical_mass                    // Note that these are currently used by node but this function should be compatible with by layer
,float64 soil_bulk_density_g_per_cm3                // Therefore, make sure to pass these as parameters,
,float64 layer_thickness                  // and not get them from soil structure or soil hydrology.
,float64 water_content_volumetric
,float64 &chem_mass_fraction_in_solution)                                  const
{  if (CORN::is_approximately<float64>(chemical_mass,0.0,0.0000001)) return 0.0;
   static const float64 g_per_cm3_to_kg_per_m3 = 1000.0;
   float64 bulk_density_kg_m3 =  soil_bulk_density_g_per_cm3 * g_per_cm3_to_kg_per_m3; //080128
   float64 water_content_gravimetric // kg water/kg soil
      = water_content_volumetric * water_density / (bulk_density_kg_m3);
   float64 K = get_constantC();
   float64 Q = get_constantQ();
   float64 w = water_content_gravimetric;  // kg water/kg soil
   float64 chem_mass_sorbed_and_in_solution   // kg salt/kg soil
      = chemical_mass / (bulk_density_kg_m3 * layer_thickness);      // THe bulk density is simply for convertion for volume
   float64 S = chem_mass_sorbed_and_in_solution;
      // equivelent to XS + w[S]
      // [S] is salt in solution (kg salt/kg water)
      // XS is sorbed salt(kg salt/kg soil)
   float64 A = w * K;
   float64 B = K * Q + w - K * S;
   float64 C = -S;
   float64 concentration_kgChem_per_kgH2O = CORN_quadratic1(A,B,C,1); // (-B + Sqr(B * B - 4 * A * C)) / (2 * A)
   chem_mass_fraction_in_solution = concentration_kgChem_per_kgH2O * w / S;
   // Converted from kgChem/kg Soil to kgChem/m3 water
   return concentration_kgChem_per_kgH2O * water_density;
}
//_2008-01-15___________________________________________________________________
/*
Private Function EquilibriumConcentration(ByVal Chemical_Mass As Single, _
  WC As Single, DZ As Single, BD As Single, K As Single, Q As Single) As Single
 Const water_density = 1000 'Water density (kg/m3)
 Dim Gravimetric_WC As Single, A As Single, B As Single, C As Single

Gravimetric_WC = WC * water_density / BD
                 get_water_plus_ice_content_gravimetric(layer)

Chemical_Mass = Chemical_Mass / (DZ * BD)
A = K * Gravimetric_WC
B = K * Q + Gravimetric_WC - K * Chemical_Mass
C = -Chemical_Mass
EquilibriumConcentration = (-B + Sqr(B * B - 4 * A * C)) / (2 * A)

End Function
*/
//______________________________________________________________________________
void Chemical_pool::inc_transformed_from(float64 transformed_M)
{  if (transformed_M != 0.0)
   {  if (ANNL_bal_accums)       ANNL_bal_accums      ->inc_transformed_from(transformed_M);
      if (GP_bal_accums_current) GP_bal_accums_current->inc_transformed_from(transformed_M);
      if (CONT_bal_accums)       CONT_bal_accums      ->inc_transformed_from(transformed_M);
      #if (REACCH_VERSION < 2)
      if (FALLOW_bal_accums)     FALLOW_bal_accums    ->inc_transformed_from(transformed_M);
      #endif
   }
}
//_1999-03-17___________________________________________________________________
float64 Chemical_pool::balance(nat8 soil_num_layers)
{  nat8 layer;
   profile_transformed_from_M = 0;
   for (layer = 1; layer <= soil_num_layers; layer ++)
   {  inc_transformed_from(transformed_from_M[layer]);
      profile_transformed_from_M += transformed_from_M[layer];
   }
   float64 balance_error = 0.0;
   if (name != LABEL_POT_MINERALIZABLE_N) // <- No need to balance pot min N     //980304
   {  float64 current_profile_content = get_current_profile_content_M();
      if (ANNL_bal_accums) balance_error = ANNL_bal_accums   ->balance(current_profile_content);
      if (GP_bal_accums_current) GP_bal_accums_current->balance(current_profile_content);
      if (CONT_bal_accums)       CONT_bal_accums   ->balance(current_profile_content);
      #if (REACCH_VERSION < 2)
      if (FALLOW_bal_accums)     FALLOW_bal_accums ->balance(current_profile_content);
      #endif
      recalibration = 0.0;                                                       //011119
   }
   return    balance_error ;
}
//_1999-03-17?__________________________________________________________________
bool Chemical_profile::start_day()
{  //080308 Now nothing to do, the mass pending just remains pending, to this new day, any applications today will simply increase the mass pending and the application rate respectively
   bool started = true;
   balance_leached_molecular = 0.0;                                              //981230
   reported_leached_molecular = 0.0;                                             //981230
   #ifdef WATERTABLE
   if (water_table_curve)
      started &= water_table_curve->start_day();                                 //151113_150925
      // Because water_table_curve is currently owned by this
      // this should be reponsible for starting it.
      // However, the the water table curves are now simulation elements
      // and probably should be owned and maintained by the instanciator.
      // Note the chemical profile probable should be Simulation_element_composite
   #endif
   return started;                                                               //151113
}
//_2007-10-15___________________________________________________________________


/* Notes for salinity

 conc =    Elec cond of soil solution * 0.64
// 0.64 is the typical conversion factor to convert salinity to concentration
 ^- kg salt / m^3 water

amount =  conc * water_cont * thickness

salinity only moves
has no transformation
no exchange
no uptake

Is applied as a flux
osmoticpot_soilsolut = - 56.25 * conc
osmoticpot_sat_extract =  osmoticpot_soilsolut * water_cont / (2.0 * field_cap)
root permeability
*/
//______________________________________________________________________________

//060207 1600 lines
//060502 1245 lines
//080920 2250 lines
//110704 1499 lines

