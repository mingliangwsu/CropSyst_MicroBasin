


#include "organic_matter/OM_residues_profile_abstract.h"
#include "land_unit_output.h"
#include "UED/library/controls.h"
#include "crop/crop_interfaced.h"
#include "soil/chemicals_profile.h"
#include "soil.h"
#include "common/weather/weather.h"
#include "corn/data_source/vv_file.h"
#include "cs_scenario_directory.h"
#include "output.h"
#include "cs_ET.h"
#include "cs_simulation.h"
#include "crop/crop_cropsyst.h"
#ifdef NITROGEN
#include "soil/nitrogen_profile.h"
#endif
#include <iomanip>
#ifdef RUSLE_DETAIL
#  include "soil/erosion_RUSLE.h"
#include "weather/storms.h"
#endif
#include "csvc.h"

using namespace std;
extern ofstream dbg_nitr;
extern float64 N2O_from_nitrification_daily;
#include "crop/canopy_growth_cover_based.h"
using namespace CropSyst;  // Not eventually everything will be under Cropsyst



#ifdef DUMP_CURVE_NUMBERS
namespace CropSyst
{
   extern std::ofstream *SCS_runoff_dat_file;                                    //131216
}
#endif
extern CS_UED_variable_code fast_graph_variables[];                              //160303
#ifdef CROPSYST_PROPER
extern bool harvest_event_failed_today ; // this is a check for Mike Rivingtons spreadsheet
#endif
namespace CropSyst {
//______________________________________________________________________________
Land_unit_with_output::Land_unit_with_output
(const CS::Identification           &LBF_ID_                                     //151026
, nat32                              cycle_shift_                                //151026
, CropSyst::Scenario                &scenario_control_and_model_options_         //130827
, const CORN::Date                  &today_                                      //130619
, const Geocoordinate               &geocoordinate_                              //151116
,const CS::Land_unit_meteorological &meteorology_                                //151128
#if (CS_VERSION==4)
,Common_simulation_log              &event_log_
#endif
,const CropSyst::Scenario_directory *scenario_directory_                         //050619
,CropSyst::Desired_variables        *daily_desired_vars_)                        //041021
: Land_unit_simulation
   (LBF_ID_
   ,cycle_shift_
   ,scenario_control_and_model_options_                                          //130827
   ,today_                                                                       //130619
   ,geocoordinate_                                                               //151116
   ,meteorology_
   #if (CS_VERSION==4)
   ,event_log_
   #endif
   ,scenario_directory_)
,harvest_UED_db         (0)
,harvest_data_src_rec   (0)
,season_UED_db          (0)
,season_data_src_rec    (0)
,annual_UED_db          (0)
,annual_data_src_rec    (0)

#if (CROPSYST_PROPER == 4)
#  ifndef __linux
#    if (!defined(REACCH_VERSION) && !defined(OFOOT_VERSION))
,        detail_txt_stream(0)                                                           //090803
#        ifdef DETAIL_DENITR
,          denitr_detail_stream  (0)                                                      //160128
#        endif
#    endif
#  endif
#  ifdef RUSLE_DETAIL
,RUSLE_detail_txt_file(0)
#  endif
#endif
#ifndef CS_INSPECTOR_VERSION
,daily_UED_db           (0)  // NYI get this from the scenario                   //030715
,daily_UED_data_src     (0)                                                      //030715
,daily_data_rec         (*this,*daily_desired_vars_)                             //030715
#endif
#if (defined(XLS_OUTPUT) || defined(UED_OUTPUT))
,daily_desired_vars           (daily_desired_vars_)                              //041021
#endif
,output_flags           (OUTPUT_COMPLETE)                                        //151227
{

   if (!daily_desired_vars_)  // disable daily output if no desired variable     //151227
   {
      output_flags ^= OUTPUT_DAILY;                                              //151227
   }

   #if (CROPSYST_PROPER == 5)
   //160530 temporarily output everything for debugging
   output_flags ^= OUTPUT_DAILY;
   #endif

   #if (CROPSYST_PROPER == 4)

   // This should be moved to land_unit_output_V4
   // and in V5 use inspector idiom.

   #ifndef __linux
//160530 #if (!defined(REACCH_VERSION) && !defined(OFOOT_VERSION))
   CORN::OS::File_name_concrete detail_txt_filename(scenario_directory_->Output(),"detail.txt");  //090803
   detail_txt_stream = new std::ofstream(detail_txt_filename.c_str());             //090803
//160530 #endif
   #endif
#ifdef RUSLE_DETAIL
   CORN::OS::File_name_concrete RUSLE_detail_txt_filename(*scenario_directory_->output_dir,"RUSLE_detail.txt"); //130818
   RUSLE_detail_txt_file = new std::ofstream(RUSLE_detail_txt_filename.c_str());
#endif
   #endif
}
//_2004-10-21___________________________________________________________________
//1603006 Land_unit_with_output::~Land_unit_with_output()
bool Land_unit_with_output::stop()                                 modification_ //160306
{
   bool stopped = Land_unit_simulation::stop();                                  //160306
   std::string event_description("Simulation period");
   if (latest_simulated_date < scenario_control_and_model_options.stop_date.get_date32()) //110104
      event_description.append(" (ended prematurely)");
   Datetime64 start_date64 = scenario_control_and_model_options.start_date .get_datetime64(); //110104
   Datetime64 end_date64 = latest_simulated_date;                                //110104
   UED::Period_record simulation_period                                          //041012
      (event_description.c_str()
      ,(nat32 )(UED_period_start_date_option | UED_period_end_date_option |UED_period_application_code_option)
      ,start_date64
      ,end_date64 // use current date because the simulation may be prematurely terminated
      ,SIMULATION_PERIOD // appl code
      ,0 // no enumeration
      ,0 // no index
      ,0 // no variable code
      );
   // Not sure why this is crashing in REACCH_VERSION (daily output is only for debug)                           160310
   #ifndef CS_INSPECTOR_VERSION
   if (daily_UED_db)
   {
      daily_UED_db   ->set_period(simulation_period);
      delete daily_UED_db;
   }
   delete daily_UED_data_src;
   #endif

   #if (CROPSYST_PROPER==4 )
   #ifndef __linux
      #if (!defined(REACCH_VERSION) && !defined(OFOOT_VERSION))
         delete detail_txt_stream; detail_txt_stream = 0;                              //131216
         #ifdef DUMP_CURVE_NUMBERS
         delete CropSyst::SCS_runoff_dat_file; CropSyst::SCS_runoff_dat_file = 0;                          //131216
         #endif
         #ifdef DETAIL_DENITR
         delete denitr_detail_stream;
         #endif
         #ifdef RUSLE_DETAIL
         if (RUSLE_detail_txt_file) delete RUSLE_detail_txt_file; RUSLE_detail_txt_file = 0; //120529
         #endif
      #endif
   #endif
   #endif
   if (harvest_UED_db)
   {
      harvest_UED_db ->set_period(simulation_period);                            //041012
      #ifndef REACCH_VERSION
      // Don't know why crashing in REACCH version
      delete harvest_UED_db;        harvest_UED_db = 0;
      #endif
   }
   if (harvest_data_src_rec)  delete harvest_data_src_rec;  harvest_data_src_rec = 0;
   if (season_UED_db)
   {  season_UED_db  ->set_period(simulation_period);                            //041012
      delete season_UED_db;         season_UED_db = 0;
   }
   delete season_data_src_rec;   season_data_src_rec = 0;
   if (annual_UED_db)
   {  annual_UED_db  ->set_period(simulation_period);                            //041012
      delete annual_UED_db;         annual_UED_db = 0;
   }
   delete annual_data_src_rec;   annual_data_src_rec = 0;
   return stopped;                                                               //160306
}
//______________________________________________________________________________
bool Land_unit_with_output::initialize()                          initialization_ //151227
{  bool inited = CropSyst::Land_unit_simulation::initialize();

   #ifndef linux
   //160303 moved from CS_mod
   #if (defined(XLS_OUTPUT) || defined(UED_OUTPUT))
   if (scenario_control_and_model_options.fast_graph && daily_desired_vars)      //160303
      daily_desired_vars->append_array_null_terminated(fast_graph_variables);    //160303
         // null terminated                                                      //100702
   #endif
   #endif
if (!inited) std::clog << "CropSyst::Land_unit_simulation::initialize failed" << std::endl;

   #ifndef __linux
   #if (!defined(REACCH_VERSION) && !defined(OFOOT_VERSION))
   #if (CROPSYST_VERSION == 4)
   organic_matter_percents_file.open(scenario_directory->Output().organic_matter_percents_dat().c_str());  //141119
   organic_matter_percents_file << "horizon\torganic_matter_biomass(%)\tmicrobial_C(%)\tlabile_C(%)\tmetastable_C(%)\tpassive_C(%)\tall_residues_biomass(kg/ha)" << std::endl; //070314
   #endif
   #endif
   #endif
   {  // Open output options and get desired variables                           //041031
      Scenario_output_options output_options;                                    //041031
      VV_File output_opts_file                                                   //041031
#if (CROPSYST_VERSION >= 5)
//NYI In version 5 the output options should be (optionally?) specified on the command line
//(or taken from the project).
(scenario_control_and_model_options.output_options_filename_rel.c_str());        //130827_041031
#else
        (scenario_control_and_model_options.output_options_filename_rel.c_str());//130827_041031
#endif
      output_opts_file.get(output_options);                                      //041031
      #if (defined(XLS_OUTPUT) || defined(UED_OUTPUT))
      if (daily_desired_vars)                                                    //140105
      output_options.list_required_variables(*daily_desired_vars);               //140104_041031
      #endif
   }
   if (output_flags & OUTPUT_DAILY)                                              //151227
   {
      CORN::OS::File_name_concrete daily_UED_filename_qual
         (get_output_directory_name(),"daily","UED");                //160309

      //161017 #ifndef CS_INSPECTOR_VERSION
      daily_UED_db         = new CropSyst_UED_database
            (daily_UED_filename_qual.c_str()
            ,(std::ios_base::out)
            ,scenario_control_and_model_options.start_date);
      daily_UED_data_src   = new CS_UED_tuple_data_source(daily_UED_db);
      daily_UED_db->write_generating_application((nat16)CS_VERSION_CODE,"CropSyst");    //140105
      //161010 #endif
   }
   #ifdef USE_CS_SIMULATION_ROTATOR
   // The simulation rotator doesn't write annual UED files for each scenario
   // The UED records are stored in memory and will be aggregated.                  //140119
   annual_UED_db        = new UED::Database_file_indexed(0,(std::ios_base::out),false);
   CORN::OS::File_name_concrete season_UED_filename(get_output_directory_name()  ,"season.UED");                      //160305
   CORN::OS::File_name_concrete harvest_UED_filename(get_output_directory_name() ,"harvest.UED");                    //160305
   CORN::OS::File_name_concrete annual_UED_filename(get_output_directory_name()  ,"annual.UED");                      //160305

   harvest_UED_db = new UED::Database_file_indexed(harvest_UED_filename.c_str(),(std::ios_base::out),false); //160305
   season_UED_db  = new UED::Database_file_indexed(season_UED_filename .c_str(),(std::ios_base::out),false); //160305
   annual_UED_db  = new UED::Database_file_indexed(annual_UED_filename .c_str(),(std::ios_base::out),false); //160305

   #else
   harvest_UED_db       = new UED::Database_file_indexed(scenario_directory->CS_output_harvest_UED_cstr,(std::ios_base::out),false);
   season_UED_db        = new UED::Database_file_indexed(scenario_directory->CS_output_season_UED_cstr ,(std::ios_base::out),false);
   annual_UED_db        = new UED::Database_file_indexed(scenario_directory->CS_output_annual_UED_cstr ,(std::ios_base::out),false);
   #endif
   harvest_UED_db ->write_generating_application((nat16)CS_VERSION_CODE,"CropSyst");     //140105
   season_UED_db  ->write_generating_application((nat16)CS_VERSION_CODE,"CropSyst");     //140105
   annual_UED_db  ->write_generating_application((nat16)CS_VERSION_CODE,"CropSyst");     //140105

   harvest_data_src_rec = new Harvest_data_source(harvest_UED_db);
   season_data_src_rec  = new Season_data_source(season_UED_db);
   annual_data_src_rec  = new Annual_data_source(annual_UED_db);
   #if ((CROPSYST_VERSION >=5 ) || defined(USE_CS_LAND_UNIT))
   //140918  Soil_interface should work in all versions, but not tested yet
   #else
   const CropSyst::Soil *soil = ref_soil();                                      //060803
   #endif

   season_data_src_rec->soil_water_profile_init = soil->ref_hydrology()->provide_water_depth_profile(true); //160412_151227
      // This is actually only needed for REACCH
   season_data_src_rec->soil_available_water_15_init = soil->ref_hydrology()->calc_available_water_depth_to(1.5); //160601
      // Special output

   std::string weather_description;                                              //050916
/*NYI actually should get from weather file is possible  151208
       (scenario_control_and_model_options.provide_geolocation()->get_station_ID_code())
*/
   // Should be able to move this to land_unit_output_V4                         //160529
   #ifndef CS_INSPECTOR_VERSION
   #if (defined(XLS_OUTPUT) || defined(UED_OUTPUT))
   if (daily_UED_data_src
//160530          && daily_desired_vars
         )                                 //140105_111221
       daily_UED_data_src->register_fields(*daily_desired_vars,soil->layers->get_number_sublayers(),UT_arbitrary_date);   //140105_041014
   #endif
   if (daily_UED_db)                                                             //111221
       daily_UED_db->initialize_with_descriptions                                //030715
         (scenario_control_and_model_options.description.brief                   //150112_130827
         ,weather_description
         ,soil->parameters_ownable->description.brief                            //150112
         ,scenario_control_and_model_options.fast_graph);
   #endif
   output_organic_matter_partitioning(true);
   return inited;
}
//_________________________________________________________________initialize__/
void Land_unit_with_output::harvest_event
(const CropSyst::Crop_interfaced &_crop_at_harvest)                modification_ //131008
{
   harvest_data_src_rec->update(_crop_at_harvest);                               //070228 was crop crop_active
   harvest_data_src_rec->record((Datetime64)get_today_date32());
}
//______________________________________________________________________________
nat32 Land_unit_with_output::perform_triggered_synchronizations_today()
{
#ifndef REACCH_VERSION
//#ifdef CROPSYST_PROPER
/*141222 RLN this was broken (although corrected now)
 * It is not necessary to check every day if period changes
 * We can now output the periods (as recorded in phenology)
 * Once at the end of the season.
 * This hasn't been implemented yet so dont delete this until reimplemented
*/
   modifiable_ CropSyst::Crop_interfaced *crop_active = crop_active_or_intercrop;//130719_131008NS
   if (crop_active)
   {
      const CropSyst::Phenology_interface &phenology = crop_active->ref_phenology();
      bool planted_today =
         phenology.started_today((Normal_crop_event_sequence)NGS_PLANTING);      //151005

      if (planted_today) latest_growth_stage_entered = NGS_PLANTING;
      if ((!latest_sync_date) || planted_today)
         latest_sync_date = (Datetime64)get_today_date32(); // If we haven't had a period yet, then today is just the start of the period.
      nat32  period_options = UED_period_start_date_option | UED_period_end_date_option |UED_period_application_code_option|UED_period_index_option|UED_period_enumeration_option|UED_period_variable_code_option;
      if (!latest_sync_date) latest_sync_date = (Datetime64)get_today_date32(); // If we haven't had a period yet, then today is just the start of the period.
      Normal_crop_event_sequence current_growth_stage
         = phenology.get_growth_stage_sequence();                                //141222
      if ((latest_growth_stage_entered!=NGS_NONE)
           && (current_growth_stage != latest_growth_stage_entered))
      {
         std::string period_description(get_growth_stage_description(latest_growth_stage_entered,false));  //140103 NYI crop_active-> parameters_ownable->is_fruit_tree()
         period_description.append(":");
         period_description.append(crop_active->get_description());
         UED::Period_record growthstage_period
            (period_description.c_str(),period_options,latest_sync_date
            ,today.get_datetime64(),GROWTH_STAGE_PERIOD
            ,latest_growth_stage_entered
            ,phenology.get_initiation_date(NGS_RESTART).get_date32()             //151005
            ,CSVC_crop_base_growth_stage);                                       //140114_050208
         latest_sync_date = (Datetime64)get_today_date32();
         #ifndef CS_INSPECTOR_VERSION
         if (daily_UED_db)                                                       //111221
             daily_UED_db->set_period(growthstage_period);
         #endif
         harvest_UED_db->set_period(growthstage_period);                         //041012
         season_UED_db->set_period(growthstage_period);                          //041012
      }
      latest_growth_stage_entered = current_growth_stage;                        //141222
   }
#endif
   return CropSyst::Land_unit_simulation_VX::perform_triggered_synchronizations_today();
}
//_2014-01-03___________________________________________________________________
bool Land_unit_with_output::start()                                              //130620
{
   bool started = Land_unit_simulation_VX::start();                              //080929
#ifdef NYI
080306 This was an attempt to output the initial data for annual reports,
but the output manager or export utility is not setup to process this.
   CORN::Date day_before_start(today); day_before_start.dec();
   DOY doy = today.get_DOY();
   if (doy == 1)
   {  // If the the simulation start date in Jan 1 then we can
      // output the initial values as if for the previous year
      // When the simulation is not started on Jan 1 outputting
      // initial values as if for the previous year would be confusing an misleading
      Year year = day_before_start.get_year();
      if (annual_data_src_rec)
      {  annual_data_src_rec->update(*get_soil() ,*ANNL_accumulators_active
            ,organic_matter_residues_profile_kg_m2 ? organic_matter_residues_profile_kg_m2->ref_residues() : 0
         ,organic_matter_residues_profile_kg_m2
               ,pond,LBF_ID,year );
         annual_data_src_rec->record(day_before_start.get_datetime64());
      }
   }
   // Currently only outputing initial values for annual outputs
   // Eventually we may add others.
#endif
   #if (CROPSYST_PROPER==4)
   #ifdef _Windows
      #ifndef USE_CS_SIMULATION_ROTATOR

         if (detail_txt_stream)
         {
//   const Crop_complete *crop_CropSyst = dynamic_cast<const Crop_complete *>(crop_active_or_intercrop);

           (*detail_txt_stream)
               << "date" << '\t'
               << "accum_deg_days" << '\t'
               << "chill_hours_remaining"<< '\t';
           (*detail_txt_stream)
               << std::endl;
         };
         #ifdef DUMP_CURVE_NUMBERS
         CORN::OS::File_name_concrete SCS_runoff_dat_filename(scenario_directory->Output(),"SCS_runoff.dat"); //131216
         CropSyst::SCS_runoff_dat_file = new std::ofstream(SCS_runoff_dat_filename.c_str());     //131216
//         SCS_runoff_dat_file->open(scenario_directory->Output().SCS_runoff_dat().c_str()); //131216
         (*CropSyst::SCS_runoff_dat_file)                                                        //131216
                     << "date" << '\t'
                     << "CN1" <<  '\t'
                     << "CN2" <<  '\t'
                     << "CN3" <<  '\t'
                     << "surface_storage";
         #endif
      #endif
      #ifdef RUSLE_DETAIL
         if (RUSLE_detail_txt_file)
            (*RUSLE_detail_txt_file)
               << "date" << '\t'
               << "precip_mm" << '\t'
               << "storm_energy" << '\t'
               << "storm_intensity" << '\t'
               << "C_factor" << '\t'
               << "mulch_factor" << '\t'
               << "moisture_factor" << '\t'
               << std::endl;
      #endif
   #endif
   #endif
   return started;                                                               //080929
}
//_2008-03-06___________________________________________________________________
bool Land_unit_with_output::end_day()
{  // We call Land_unit_simulation_VX:: end_day first because it update accumulators
   bool result = Land_unit_simulation_VX::end_day();

//std::clog << "debug: daily output disabled" << std::endl;

   #ifndef CS_INSPECTOR_VERSION
   if (daily_UED_data_src)                                                       //111228
   {
      daily_UED_data_src->set_date(today.get_datetime64());                      //070228
      //#ifndef REACCH_VERSION
      // This is crashing in REACCH
      daily_UED_data_src->set(daily_data_rec);                                   //070228
      //#endif
   }
   #endif
   #if (CROPSYST_PROPER==4)
   #if (!defined(REACCH_VERSION) && !defined(OFOOT_VERSION))
   #ifdef _Windows
      if (detail_txt_stream)
      {
         const CropSyst::Crop_interfaced *crop_active =                          //131008
         #ifdef INTERCROPPING
            get_predominant_crop();  //130716 this is just debugging output so only need predominant crop
         #else
            crop_active_or_intercrop;
         #endif
         #if (CS_VERSION==4)
         if (crop_active)
         {
            (*detail_txt_stream)
            << today.as_string() << '\t'
            << crop_active->get_accum_degree_days(false) << '\t'
            #ifdef CROP_ORCHARD
            << crop_active->get_fruit_chill_hours_remaining() << '\t'
            #endif
             ;
const CropSyst::Crop_complete *crop_activeA = dynamic_cast <const CropSyst::Crop_complete *>(crop_active_or_intercrop);
(*detail_txt_stream)
<< '\t' << crop_activeA->output_transpiration_use_eff
<< '\t' << crop_activeA->output_degree_hours_above_30_today;
//<< '\t' << crop_activeA-output_degree_hours_above_34_today


            // << crop_active->get_solid_canopy_interception()
            (*detail_txt_stream)
            << endl;


         }





/*
         #if (CROPSYST_VERSION == 4)
         (*detail_txt_stream) << "ET_model=" << ET_ref->get_selected_ET_model_label() << endl;
         #else
         // V5 will output this to explainations
         #endif
*/
         #else
         // In V5 (and eventually V4) use explainations
         #endif
      }
   #endif
   #endif
   #endif

   return result;
}
//_2007-02-27___________________________________________________________________
bool Land_unit_with_output::start_growing_season                                 //160324
      #if ((REACCH_VERSION==2) || (CS_VERSION >= 5) || defined(INTERCROPPING) || defined(OFOOT_VERSION))
      (modifiable_ CropSyst::Crop_interfaced &crop_at_start_season)
      #else
      ()
      #endif
{  bool started = Land_unit_simulation_VX::start_growing_season
      #if ((REACCH_VERSION==2) || (CS_VERSION >= 5) || defined(INTERCROPPING) || defined(OFOOT_VERSION))
      (crop_at_start_season);
      #else
      ();
      #endif
   if (season_data_src_rec && soil)                                              //160324
   {
      season_data_src_rec->soil_water_profile_init                               //160324
         = soil->ref_hydrology()->provide_water_depth_profile(true);             //160412_160324
      season_data_src_rec->soil_available_water_15_init
         = soil->ref_hydrology()->calc_available_water_depth_to(1.5);            //160601
   }
   return started;
}
//_2016-03-23__________________________________________________________________/
bool Land_unit_with_output::end_growing_season
#if ((REACCH_VERSION==2) || (CROPSYST_VERSION >= 5) || defined(INTERCROPPING)|| defined(OFOOT_VERSION))
(CropSyst::Crop_interfaced &_crop_at_end_season)                                 //131008NS
#else
()
#endif
{

   output_growing_season
   #if ((REACCH_VERSION==2) || (CROPSYST_VERSION >= 5) || defined(INTERCROPPING)|| defined(OFOOT_VERSION))
      (_crop_at_end_season);                                                     //130716
   #else
      ();                                                                        //070227
   #endif
   //160202 now done here for all versions    #ifdef REACCH_VERSION
   //160202    // In CropSyst proper, harvest report is iniciated by CropSyst_model which REACCH does not have
   /*160712 actually this should already be picked up by harvest procession
   harvest_event(*crop_at_harvest);                                               //151216
   */
   //160202  #endif
   bool result =
      Land_unit_simulation_VX::end_growing_season
      #if ((REACCH_VERSION==2) || (CROPSYST_VERSION >= 5) || defined(INTERCROPPING)|| defined(OFOOT_VERSION))
      (_crop_at_end_season);                                                     //130716
      #else
      ();                                                                        //041118
      #endif
   #ifdef CROPSYST_PROPER
   harvest_event_failed_today = false;                                           //16020 This was in CS_mod.cpp
   //141222 latest_growth_stage_entered will be obsolete once I reimplement the output of phenology periods.
   latest_growth_stage_entered = NGS_NONE;                                       //041205
   #endif
   return result;                                                                //070321
}
//______________________________________________________________________________
void Land_unit_with_output::output_growing_season
#if ((REACCH_VERSION==2) || (CROPSYST_VERSION >= 5) || defined(INTERCROPPING)|| defined(OFOOT_VERSION))
(const CropSyst::Crop_interfaced &_crop_at_end_season)                           //131008NS
#else
()
#endif
{
#ifdef INTERCROPPING
   const CropSyst::Crop_interfaced *crop_at_end_season = &_crop_at_end_season; // this line is just temporary eventually we will use reference every where in this method //131008NS
#else
   if (!crop_at_end_season) return;                                              //050209
#endif
   Datetime64 planting_or_restart_date                                           //041205
      = crop_at_end_season->
         ref_phenology().get_initiation_date(NGS_PLANTING).get_datetime64();     //041205_151005

   /* NYI Output each of the stages
   for each growth_stage
   if the stage start date of growth_stage is valid (started)
   {
      nat32  period_options = UED_period_start_date_option | UED_period_end_date_option |UED_period_application_code_option|UED_period_index_option|UED_period_enumeration_option|UED_period_variable_code_option;
      //if (!latest_sync_date) latest_sync_date = (Datetime64)get_today_date32(); // If we haven't had a period yet, then today is just the start of the period.
      //Normal_crop_event_sequence current_growth_stage = crop_active->ref_phenology().get_growth_stage_sequence(); //141222
      {
         std::string period_description(get_growth_stage_description(latest_growth_stage_entered,false)); //140103 NYI crop_active-> parameters_ownable->is_fruit_tree()));
         period_description.append(":");
         period_description.append(crop_active->get_description());
         UED::Period_record growthstage_period
            (period_description.c_str()
            ,period_options
            ,growth stage start date
            ,growth stage end date
            ,GROWTH_STAGE_PERIOD,latest_growth_stage_entered,crop_active->get_restart_date().get_date32(),CSVC_crop_base_growth_stage); //140114_050208
         latest_sync_date = (Datetime64)get_today_date32();
         #if ((REACCH_VERSION<2) || defined(_DEBUG))
         if (daily_UED_db)                                                       //111221
         daily_UED_db->set_period(growthstage_period);
         #endif
         harvest_UED_db->set_period(growthstage_period);                         //041012
         season_UED_db->set_period(growthstage_period);                          //041012
      }
   }
   */

   UED::Period_record season_period                                              //041012
      (crop_at_end_season->get_description() // "Growing season"
      ,UED_period_start_date_option|UED_period_end_date_option|UED_period_application_code_option|UED_period_index_option|UED_period_variable_code_option|UED_period_variable_code_option
      ,planting_or_restart_date                                                  //041205
      ,today.get_datetime64()                                                    //140105_070227
      ,GROWING_SEASON_PERIOD
      ,0 // no enumeration
      ,crop_at_end_season->
            ref_phenology().get_initiation_date(NGS_RESTART)                     //151005
            .get_date32() // The start/restart date is not used to uniquely identify the season
      ,CSVC_crop_base_name);  // NO CSVC
   //output growing season period to UED files
   #if (CROPSYST_VERSION >= 5)
   // I want to output the  management file/designation
   #endif
   //160309 #if ((REACCH_VERSION<2) || defined(_DEBUG))
   //160310 #ifndef REACCH_VERSION
   // Not sure why this is crashing for REACCH //160309
   #ifndef CS_INSPECTOR_VERSION
   if (daily_UED_db)                                                             //111221
       daily_UED_db->set_period(season_period);
   #endif
   //160310 #endif
   //160309 #endif
   harvest_UED_db->set_period(season_period);                                    //041012
   season_UED_db->set_period(season_period);                                     //041012
   annual_UED_db->set_period(season_period);                                     //041012
   #ifdef CHEM_PROFILE
   Soil_chemicals_profile *soil_chemicals = get_soil_chemicals();
   #endif
   #ifdef NITROGEN
   Chemical_balance_accumulators *NO3_GP_bal_accums = (soil_chemicals && soil_chemicals ->NO3) ? soil_chemicals->NO3->GP_bal_accums_current: 0;  //050114
   Chemical_balance_accumulators *NH4_GP_bal_accums = (soil_chemicals && soil_chemicals ->NH4) ? soil_chemicals->NH4->GP_bal_accums_current: 0;  //050114
   #endif
   #if ((CROPSYST_VERSION >=5 ) || defined(USE_CS_LAND_UNIT))
   //140918  Soil_interface should work in all versions, but not tested yet
   #else
   const CropSyst::Soil *soil = ref_soil();                                      //060803
   #endif
   season_data_src_rec->update
      (*crop_at_end_season
      ,*soil/*get_soil()*/
      ,GP_accumulators_active
      #ifdef NITROGEN
      ,NO3_GP_bal_accums                                                         //050114
      ,NH4_GP_bal_accums                                                         //050114
      #endif
      ,pond
      ,(organic_matter_residues_profile_kg_m2 ? organic_matter_residues_profile_kg_m2->mod_residues() : 0)
      ,ID.number);                                                               //151026
   season_data_src_rec->record((Datetime64)get_today_date32());
}
//_2005-01-14____________________________________________output_growing_season_/
bool Land_unit_with_output::end_year()
{  bool result = Land_unit_simulation_VX::end_year();
      #if ((CROPSYST_VERSION >=5 ) || defined(USE_CS_LAND_UNIT))
      //140918  Soil_interface should work in all versions, but not tested yet
      #else
       CropSyst::Soil *soil = mod_soil();                                        //060803
      #endif

   if (annual_data_src_rec)                                                      //050114
   {
      annual_data_src_rec->update(*soil,*ANNL_accumulators_active                //050114
      ,organic_matter_residues_profile_kg_m2 ? organic_matter_residues_profile_kg_m2->mod_residues() : 0    //050726
      ,organic_matter_residues_profile_kg_m2
      ,pond,ID.number,today.get_year());                                         //151026
      annual_data_src_rec->record(today.get_datetime64());                       //140224_050114
   }
   #ifndef CS_INSPECTOR_VERSION
   #ifdef REACCH_VERSION
   // This may have been crashing in proper (it was marked as NYI) //160310

   if (daily_UED_db)
      daily_UED_db->finish();

   #endif
   #endif
   output_organic_matter_partitioning(false);                                    //070214
   #if (CS_VERSION==4)
   #ifdef RUSLE_DETAIL
   if (RUSLE_detail_txt_file && soil && soil->erosion)                           //160506
      soil->erosion->dump_year_days(*RUSLE_detail_txt_file);                     //160506
   #endif
   #endif
   return result;                                                                //111031
}
//_2001-02-02___________________________________________________________________
bool Land_unit_with_output::start_year()                           modification_
{  // Note that this isn't necessarily Jan 1, so we need to use the current date
   #if ((CROPSYST_VERSION >=5 ) || defined(USE_CS_LAND_UNIT))
   //140918  Soil_interface should work in all versions, but not tested yet
   #else
   const CropSyst::Soil *soil = ref_soil();                                      //161008_060803
   #endif
   //160309 #if ((REACCH_VERSION<2) || defined(_DEBUG))
   #ifndef CS_INSPECTOR_VERSION
   if (daily_UED_db)                                                             //111221
   {  soil->output_layering            (*daily_UED_db);
      soil->output_hydraulic_properties(*daily_UED_db); // This was added for Marcello and Andrea Di Guardo  //070209
   }
   #endif

   #ifdef CHEM_PROFILE
   Soil_chemicals_profile *soil_chemicals = get_soil_chemicals();
   #ifdef NITROGEN
   NO3_Profile *NO3 = soil_chemicals ? soil_chemicals->NO3 : 0;
   NH4_Profile *NH4 = soil_chemicals ? soil_chemicals->NH4 : 0;
   if (NO3 && NH4)                                                               //020529
   {  if (NO3) NO3->update_YLY_bal_reporter();
      if (NH4) NH4->update_YLY_bal_reporter();
   }
   // reporters must be updated before we reset accumulators in start_of_year
   #endif
   //160309 #endif
   #endif
   bool started = Land_unit_simulation_VX::start_year();
   return started;
}
//_2004-10-14___________________________________________________________________
void Land_unit_with_output::output_organic_matter_partitioning(bool at_start)
{
   #if (CROPSYST_PROPER == 4)

   // Move this land_unit_output_V4
   // and add these outputs using inspection

   #ifndef __linux
   #if (!defined(REACCH_VERSION) && !defined(OFOOT_VERSION))
   if (scenario_control_and_model_options.organic_matter_and_residue_model_labeled.get() != multiple_SOM_multiple_residues)
   {  organic_matter_percents_file << "This output is only available with the 'Microbial, stable organic matter and residues with decomposition' submodel." << endl;
      return;
   }
   #endif
   #endif

   #endif


   #if ((CROPSYST_VERSION >=5 ) || defined(USE_CS_LAND_UNIT))
   //140918  Soil_interface should work in all versions, but not tested yet
   #else
   const CropSyst::Soil *soil = ref_soil();                                      //161008
   #endif
   if (!soil) return;
   const Soil_layers_interface *layers = soil->ref_layers();                     //160412
   if (!layers) return;
   nat8 soil_num_layers = layers->get_number_layers();
   nat8 last_horizon = 1;                                                        //150821
   nat8 horizon_start_layer = 1;
   nat8 horizon_end_layer = 1;
   float64 soil_mass_horizon = 0.0;
   #if (CROPSYST_PROPER == 4)

   // Move this land_unit_output_V4
   // and add these outputs using inspection
      #ifndef __linux
         #if (!defined(REACCH_VERSION) && !defined(OFOOT_VERSION))
         if (at_start)  organic_matter_percents_file << "Start" << endl;
         else           organic_matter_percents_file << today.get_year() << "(Dec 31)" << endl;
         #endif
      #endif

   for (nat8 layer = 1; layer <= soil_num_layers; layer++)
   {
      nat8 horizon = layers->get_horizon_at_layer(layer);
      if ((horizon != last_horizon) || (layer == soil_num_layers))
      {
         // output the horizon percentages
         float64 microbial_C_mass_horizon    = organic_matter_residues_profile_kg_m2->get_mass_from_layer_to_layer(C_MASS_TOTAL,INCLUDE_MICROBIAL_BM         ,horizon_start_layer,horizon_end_layer,1.0);
         float64 labile_C_mass_horizon       = organic_matter_residues_profile_kg_m2->get_mass_from_layer_to_layer(C_MASS_TOTAL,INCLUDE_LABILE_ACTIVE_SOM    ,horizon_start_layer,horizon_end_layer,1.0);
         float64 metasatable_C_mass_horizon  = organic_matter_residues_profile_kg_m2->get_mass_from_layer_to_layer(C_MASS_TOTAL,INCLUDE_METASTABLE_ACTIVE_SOM,horizon_start_layer,horizon_end_layer,1.0);
         float64 passive_C_mass_horizon      = organic_matter_residues_profile_kg_m2->get_mass_from_layer_to_layer(C_MASS_TOTAL,INCLUDE_PASSIVE_SOM          ,horizon_start_layer,horizon_end_layer,1.0);
         float64 organic_matter_C_mass         = microbial_C_mass_horizon + labile_C_mass_horizon + metasatable_C_mass_horizon+ passive_C_mass_horizon;
         if (organic_matter_C_mass > 0)
         {
         float64 microbial_percent           = microbial_C_mass_horizon   / organic_matter_C_mass * 100.0;
         float64 labile_percent              = labile_C_mass_horizon      / organic_matter_C_mass * 100.0;
         float64 metastable_percent          = metasatable_C_mass_horizon / organic_matter_C_mass * 100.0;
         float64 passive_percent             = passive_C_mass_horizon     / organic_matter_C_mass * 100.0;
         float64 organic_matter_biomass      = organic_matter_residues_profile_kg_m2->get_mass_from_layer_to_layer(BIOMASS_TOTAL,INCLUDE_SOM_AND_MICROBIAL ,horizon_start_layer,horizon_end_layer,1.0);
         float64 organic_matter_percent      = organic_matter_biomass      / soil_mass_horizon   * 100.0;
         float64 residue_mass_kg_ha          = per_m2_to_per_ha(organic_matter_residues_profile_kg_m2->get_mass_from_layer_to_layer(BIOMASS_TOTAL,INCLUDE_RESIDUE_OM          ,horizon_start_layer,horizon_end_layer,1.0));   //070316
         // Set up for next horizon
         horizon_start_layer  = layer;
         #ifdef __linux
         }
         #else
         #if (!defined(REACCH_VERSION) && !defined(OFOOT_VERSION))
         organic_matter_percents_file << setw(8) << setprecision(4) << ((int)last_horizon) <<"\t" << organic_matter_percent <<"\t" << microbial_percent <<"\t" << labile_percent <<"\t" << metastable_percent <<"\t" << passive_percent<<"\t" << residue_mass_kg_ha << endl;
         } else
            organic_matter_percents_file << setw(8) << ((int)last_horizon) <<"\t" << "No SOM" << endl;
         #else
         }
         #endif
         #endif
         soil_mass_horizon = 0.0;
      }
      float64 soil_mass_layer = soil->get_mass_kg_m2(layer);
      soil_mass_horizon       += soil_mass_layer;
      horizon_end_layer    = layer;
      last_horizon = horizon;
   }

   #endif

}
//_2007-03-14_______________________________output_organic_matter_partitioning_/
#ifdef DETAIL_DENITR
std::ofstream &Land_unit_with_output::provide_denitr_detail()         provision_
{
   if (!denitr_detail_stream)
   {
      CORN::OS::Directory_entry_name_concrete denitr_detail_filename
         (get_output_directory_name(),L"denitr_detail",L"dat");
      denitr_detail_stream = new std::ofstream(denitr_detail_filename.c_str());
   }
   return *denitr_detail_stream;
}
//_2016-01-28___________________________________________________________________
#endif
} // namespace CropSyst

//060306 263 lines
//060727 237 lines

